<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>verilog on Techiedeepdive</title>
    <link>/tags/verilog/</link>
    <description>Recent content in verilog on Techiedeepdive</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
    <lastBuildDate>Sat, 25 Feb 2023 00:00:00 +0000</lastBuildDate><atom:link href="/tags/verilog/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Weekend project - Python Hardware Description Language - PHDL</title>
      <link>/posts/2023/02/weekend-project-python-hardware-description-language-phdl/</link>
      <pubDate>Sat, 25 Feb 2023 00:00:00 +0000</pubDate>
      
      <guid>/posts/2023/02/weekend-project-python-hardware-description-language-phdl/</guid>
      <description>It&amp;rsquo;s Saturday night and I have been cleaning up my github repos. And I found this old defunct project I wrote few years ago. So, I thought to write this post about it.
This is a quick prototype for Python Hardware Description Language(Ironically, Named PHDL). Basically, I wanted to figure out semantics to specify verilog design programmatically. I started with defining components I need to generate a module. The snippet below shows Port and Parameter.</description>
    </item>
    
    <item>
      <title>How to read network tunnel packets in verilog using VPI</title>
      <link>/posts/2023/01/how-to-read-network-tunnel-packets-in-verilog-using-vpi/</link>
      <pubDate>Sun, 22 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>/posts/2023/01/how-to-read-network-tunnel-packets-in-verilog-using-vpi/</guid>
      <description>In previous post, I went through example how to get raw IP packets instead of going to link/phy layer. So, in this post, I thought what if i have IP stack in verilog and i want to get actual IP packets from the interface instead of creating packets myself? why not?! It&amp;rsquo;s slow sunday after all.
So, the idea is using VPI to get the packets and pass it back to verilog.</description>
    </item>
    
    <item>
      <title>verilator - Hello World and Beyond</title>
      <link>/posts/2022/10/verilator-hello-world-and-beyond/</link>
      <pubDate>Sun, 23 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>/posts/2022/10/verilator-hello-world-and-beyond/</guid>
      <description>verilator is, well, I will just paste the wiki one-liner here
 Verilator is a free and open-source software tool which converts Verilog to a cycle-accurate behavioral model in C++ or SystemC.
 Similar to iverilog, It compiles verilog to a different language but verilator generates C++ not the iverilog-specific commands.
Installation  Link to heading   git clone https://github.com/verilator/verilator autoconf ./configure --prefix=`pwd`/build make install Or we can use the pre-built packages.</description>
    </item>
    
    <item>
      <title>How much riscv verilog I can write in 5 hours</title>
      <link>/posts/2022/01/how-much-riscv-verilog-i-can-write-in-5-hours/</link>
      <pubDate>Mon, 03 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>/posts/2022/01/how-much-riscv-verilog-i-can-write-in-5-hours/</guid>
      <description>While I was waiting for my weekly chicken roast to cook, I had this really bad idea for a challenge. how much riscv verilog i can write from scratch in the next 2 hours until the chicken is done?
So, yeah that&amp;rsquo;s what I did on the last day of new year vacation.
2 hours to V hours  Link to heading   I thought to start with a skeleton for single-cycle (See [H and H][1]) and try to build the blocks bottom up style.</description>
    </item>
    
  </channel>
</rss>
