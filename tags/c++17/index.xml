<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>c&#43;&#43;17 on Techiedeepdive</title>
    <link>/tags/c&#43;&#43;17/</link>
    <description>Recent content in c&#43;&#43;17 on Techiedeepdive</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
    <lastBuildDate>Sat, 09 Nov 2024 00:00:00 +0000</lastBuildDate><atom:link href="/tags/c++17/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>C&#43;&#43;17 - Aggregate Initialization extension</title>
      <link>/posts/2024/11/c-17-aggregate-initialization-extension/</link>
      <pubDate>Sat, 09 Nov 2024 00:00:00 +0000</pubDate>
      
      <guid>/posts/2024/11/c-17-aggregate-initialization-extension/</guid>
      <description>In c++11, aggregate initialization was introduced to use initializer_list to init class types.
struct D { string name; int v; }; int main() { D d{&amp;#34;dd&amp;#34;, 4}; cout &amp;lt;&amp;lt; d.i&amp;lt;&amp;lt; endl; } The trick it didn&amp;rsquo;t allow inheritance for the initialization. In c++17, that was resolved by using nested aggregate extension
struct D { string name; int v; }; struct DD : D { float f; }; int main() { DD d{{&amp;#34;dd&amp;#34;, 4}, 1.</description>
    </item>
    
    <item>
      <title>C&#43;&#43;17 - Structure binding</title>
      <link>/posts/2024/11/c-17-structure-binding/</link>
      <pubDate>Sat, 09 Nov 2024 00:00:00 +0000</pubDate>
      
      <guid>/posts/2024/11/c-17-structure-binding/</guid>
      <description>structure binding is a way to decompose structure/array similar to python unpacking.
In this example, u and v types are aliases for the structure elements i and s of anonymous variable that copied structure m.
#include &amp;lt;string&amp;gt;#include &amp;lt;iostream&amp;gt; using namespace std; struct Mystruct { int i = 0; std::string s; }; int main() { { Mystruct m; auto [u, v] = m; } return 0; } When using reference, now u and v are reference to m1.</description>
    </item>
    
  </channel>
</rss>
