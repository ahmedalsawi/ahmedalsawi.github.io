<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Pcie on Techiedeepdive</title>
    <link>/tags/pcie/</link>
    <description>Recent content in Pcie on Techiedeepdive</description>
    <generator>Hugo</generator>
    <language>en</language>
    <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
    <lastBuildDate>Thu, 15 May 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="/tags/pcie/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Corundum - Open source NIC - Hello World</title>
      <link>/posts/2025/05/corundum-open-source-nic-hello-world/</link>
      <pubDate>Thu, 15 May 2025 00:00:00 +0000</pubDate>
      <guid>/posts/2025/05/corundum-open-source-nic-hello-world/</guid>
      <description>&lt;p&gt;&lt;code&gt;Corundum&lt;/code&gt; is very interesting project because somehow it managed to include implementations of Ethernet, PCIe and AXI-S. This is my attempt to deconstruct the source code and understand the the engineering miracle that Corundum is.&lt;/p&gt;&#xA;&lt;h1 id=&#34;installation&#34;&gt;&#xA;  Installation&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#installation&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;Link to heading&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;Link to heading&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p&gt;Let&amp;rsquo;s start by installing some dependencies&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sudo apt install -y &lt;span style=&#34;color:#79c0ff&#34;&gt;\&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#79c0ff&#34;&gt;&lt;/span&gt;    git make gcc g++ clang &lt;span style=&#34;color:#79c0ff&#34;&gt;\&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#79c0ff&#34;&gt;&lt;/span&gt;    python3 python3-pip python3-venv &lt;span style=&#34;color:#79c0ff&#34;&gt;\&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#79c0ff&#34;&gt;&lt;/span&gt;    verilator &lt;span style=&#34;color:#79c0ff&#34;&gt;\&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#79c0ff&#34;&gt;&lt;/span&gt;    iverilog &lt;span style=&#34;color:#79c0ff&#34;&gt;\&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#79c0ff&#34;&gt;&lt;/span&gt;    gtkwave &lt;span style=&#34;color:#79c0ff&#34;&gt;\&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#79c0ff&#34;&gt;&lt;/span&gt;    libpcap-dev &lt;span style=&#34;color:#79c0ff&#34;&gt;\&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#79c0ff&#34;&gt;&lt;/span&gt;    libelf-dev&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Then in a &lt;code&gt;.venv&lt;/code&gt;, We need to install &lt;code&gt;cocotb&lt;/code&gt; and some other libraries&lt;/p&gt;</description>
    </item>
    <item>
      <title>Qemu - Data object exchange DOE</title>
      <link>/posts/2023/04/qemu-data-object-exchange-doe/</link>
      <pubDate>Sat, 01 Apr 2023 00:00:00 +0000</pubDate>
      <guid>/posts/2023/04/qemu-data-object-exchange-doe/</guid>
      <description>&lt;p&gt;This is a quick write-up about Qemu DOE emulation. DOE is part of PCIe and CXL extended capabilities. Technically, It&amp;rsquo;s optional but is important part of IDE starting gen5.&lt;/p&gt;&#xA;&lt;p&gt;Starting with &lt;code&gt;cxl_usp_read_config&lt;/code&gt; is one of the places where &lt;code&gt;pcie_doe_read_config&lt;/code&gt; is called. It seems it&amp;rsquo;s only supported with CXL which kinda matches what kernel implements. If it&amp;rsquo;s DOE extended address, it will fall back to &lt;code&gt;pci_default_read_config&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ff7b72&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#ff7b72&#34;&gt;uint32_t&lt;/span&gt; &lt;span style=&#34;color:#d2a8ff;font-weight:bold&#34;&gt;cxl_usp_read_config&lt;/span&gt;(PCIDevice &lt;span style=&#34;color:#ff7b72;font-weight:bold&#34;&gt;*&lt;/span&gt;d, &lt;span style=&#34;color:#ff7b72&#34;&gt;uint32_t&lt;/span&gt; address, &lt;span style=&#34;color:#ff7b72&#34;&gt;int&lt;/span&gt; len)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    CXLUpstreamPort &lt;span style=&#34;color:#ff7b72;font-weight:bold&#34;&gt;*&lt;/span&gt;usp &lt;span style=&#34;color:#ff7b72;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#d2a8ff;font-weight:bold&#34;&gt;CXL_USP&lt;/span&gt;(d);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#ff7b72&#34;&gt;uint32_t&lt;/span&gt; val;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#ff7b72&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#d2a8ff;font-weight:bold&#34;&gt;pcie_doe_read_config&lt;/span&gt;(&lt;span style=&#34;color:#ff7b72;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;usp&lt;span style=&#34;color:#ff7b72;font-weight:bold&#34;&gt;-&amp;gt;&lt;/span&gt;doe_cdat, address, len, &lt;span style=&#34;color:#ff7b72;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;val)) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#ff7b72&#34;&gt;return&lt;/span&gt; val;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#ff7b72&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#d2a8ff;font-weight:bold&#34;&gt;pci_default_read_config&lt;/span&gt;(d, address, len);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;pcie_doe_read_config&lt;/code&gt; reads the fields when address matches the DW in DOW extended configuration address space. Other than configuration access, The important thing here is reading/writing from &lt;code&gt;read_mbox&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Qemu - PCIe SRIOV and virtual function</title>
      <link>/posts/2023/04/qemu-pcie-sriov-and-virtual-function/</link>
      <pubDate>Sat, 01 Apr 2023 00:00:00 +0000</pubDate>
      <guid>/posts/2023/04/qemu-pcie-sriov-and-virtual-function/</guid>
      <description>&lt;p&gt;This is a quick write-up about SRIOV and virtual functions emulation in Qemu. From &lt;a href=&#34;https://docs.vmware.com/en/VMware-vSphere/7.0/com.vmware.vsphere.networking.doc/GUID-CC021803-30EA-444D-BCBE-618E0D836B9F.html&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;link&lt;/a&gt;&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;SR-IOV is a specification that allows a single Peripheral Component Interconnect Express (PCIe) physical device under a single root port to appear as multiple separate physical devices to the hypervisor or the guest operating system.&lt;/p&gt;&#xA;&lt;p&gt;SR-IOV uses physical functions (PFs) and virtual functions (VFs) to manage global functions for the SR-IOV devices. PFs are full PCIe functions that are capable of configuring and managing the SR-IOV functionality. It is possible to configure or control PCIe devices using PFs, and the PF has full ability to move data in and out of the device. VFs are lightweight PCIe functions that support data flowing but have a restricted set of configuration resources.&lt;/p&gt;</description>
    </item>
    <item>
      <title>PCIE IDE Linux upcoming support</title>
      <link>/posts/2023/03/pcie-ide-linux-upcoming-support/</link>
      <pubDate>Sun, 19 Mar 2023 00:00:00 +0000</pubDate>
      <guid>/posts/2023/03/pcie-ide-linux-upcoming-support/</guid>
      <description>&lt;h1 id=&#34;intro&#34;&gt;&#xA;  Intro&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#intro&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;Link to heading&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;Link to heading&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p&gt;IDE is part of pcie starting PCIe and CXL. The transport channel for SPDM(the protocol used for IDE) is Data Object Exchange (DOE). Although DOE is supported already as an optional mailbox communication protocol, IDE/SPDM is not supported in mainline kernel yet.&lt;/p&gt;&#xA;&lt;p&gt;IDE is based on SPDM (CMA defines how SPDM applies to PCIE) and IDE defines the vendor specific messages after SPDM standard authentication protocol.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Security Protocol and Data Model(SPDM) primer</title>
      <link>/posts/2023/02/security-protocol-and-data-modelspdm-primer/</link>
      <pubDate>Sun, 19 Feb 2023 00:00:00 +0000</pubDate>
      <guid>/posts/2023/02/security-protocol-and-data-modelspdm-primer/</guid>
      <description>&lt;p&gt;SPDM defines the messages exchange protocol to do the following tasks&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;The specification-defined message exchanges enable Requesters to:&#xA;Discover and negotiate the security capabilities of a Responder.&#xA;Authenticate or provision an identity of a Responder.&#xA;Retrieve the measurements of a Responder.&#xA;Securely establish cryptographic session keys to construct a secure communication channel for the transmission&#xA;or reception of application data.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;In English, SPDM allows requester to know the capability of responder, encrypt/decrypt stuff.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Deepdive - DOE CXL Linux driver</title>
      <link>/posts/2023/02/deepdive-doe-cxl-linux-driver/</link>
      <pubDate>Fri, 17 Feb 2023 00:00:00 +0000</pubDate>
      <guid>/posts/2023/02/deepdive-doe-cxl-linux-driver/</guid>
      <description>&lt;p&gt;This post is about DOE which is Data Object Exchange which is used by CMA to implement SPDM for PCI/CXL IDE specification(starting Gen5, I think).&#xA;I can&amp;rsquo;t download ENC on PCI SIG, So the next best thing is reading the Linux kernel driver that uses DOE. Luckily, CXL driver uses it.  win-win!&lt;/p&gt;&#xA;&lt;h1 id=&#34;entry-point-the-probe&#34;&gt;&#xA;  Entry point the probe&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#entry-point-the-probe&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;Link to heading&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;Link to heading&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p&gt;Starting with &lt;code&gt;drivers/cxl/pci.c&lt;/code&gt;, &lt;code&gt;.probe&lt;/code&gt; is called with devices by PCI core.&lt;/p&gt;</description>
    </item>
    <item>
      <title>PCIe IDE - Integrity and Data Encryption</title>
      <link>/posts/2023/02/pcie-ide-integrity-and-data-encryption/</link>
      <pubDate>Fri, 17 Feb 2023 00:00:00 +0000</pubDate>
      <guid>/posts/2023/02/pcie-ide-integrity-and-data-encryption/</guid>
      <description>&lt;p&gt;The security components are divided 3 components&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;SPDM - Security Protocol and Data Model: A standard defined by [2][DMTF] for key management&lt;/li&gt;&#xA;&lt;li&gt;CMA  - Component Measurement and Authentication: defined by PCI SIG and It&amp;rsquo;s adaptation of SPDM&lt;/li&gt;&#xA;&lt;li&gt;DOE  - Data Object Exchange: defines by PCI SIG, CMA defines DOE to transport SPDM messages between requester and responder for key/cert exchange.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Note that CMA and SPDM are lumped together in the spec as I see it CMA is basically SPDM with extra requirement or rules.  DOE is just extended capability in the configuration address space where it allows the host and device to exchange messages using 2 mailboxes registers.&lt;/p&gt;</description>
    </item>
    <item>
      <title>PCIe physical layer 8b/10b encoder</title>
      <link>/posts/2023/02/pcie-physical-layer-8b/10b-encoder/</link>
      <pubDate>Fri, 17 Feb 2023 00:00:00 +0000</pubDate>
      <guid>/posts/2023/02/pcie-physical-layer-8b/10b-encoder/</guid>
      <description>&lt;p&gt;This is a quick post about 8b/10b encoder in PCIE Gen1/2. Not that change in Gen3.&lt;/p&gt;&#xA;&lt;p&gt;From Mindeshare PCIe book, encoder balances out the&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Maintaining DC Balance. PCIe uses an AC‐coupled link, placing a capaci‐&#xA;tor serially in the path to isolate the DC part of the signal from the other end&#xA;of the Link. This allows the Transmitter and Receiver to use different com‐&#xA;mon‐mode voltages and makes the electrical design easier for cases where&#xA;the path between them is long enough that they’re less likely to have exactly&#xA;the same reference voltages.&lt;/p&gt;</description>
    </item>
    <item>
      <title>PCIe Galois LSFR scrambler - one way to do it!</title>
      <link>/posts/2023/02/pcie-galois-lsfr-scrambler-one-way-to-do-it/</link>
      <pubDate>Wed, 15 Feb 2023 00:00:00 +0000</pubDate>
      <guid>/posts/2023/02/pcie-galois-lsfr-scrambler-one-way-to-do-it/</guid>
      <description>&lt;p&gt;This is a quick post about PCIe scrambler as part of the physical layer. The polynomial is&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;X^16 + X^5 + X^4 + X^3 + 1.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;&lt;img src=&#34;/pcie_scrambler.png&#34; alt=&#34;Example image&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;From &lt;a href=&#34;https://en.wikipedia.org/wiki/Linear-feedback_shift_register&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Wiki&lt;/a&gt;, This type of LSFR is called &lt;code&gt;Galois LSFR&lt;/code&gt; where bits at taps(xor) is inverted when bit is 1.&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Named after the French mathematician Évariste Galois, an LFSR in Galois configuration, which is also known as modular, internal XORs, or one-to-many LFSR, is an alternate structure that can generate the same output stream as a conventional LFSR (but offset in time).[5] In the Galois configuration, when the system is clocked, bits that are not taps are shifted one position to the right unchanged. The taps, on the other hand, are XORed with the output bit before they are stored in the next position. The new output bit is the next input bit. The effect of this is that when the output bit is zero, all the bits in the register shift to the right unchanged, and the input bit becomes zero. When the output bit is one, the bits in the tap positions all flip (if they are 0, they become 1, and if they are 1, they become 0), and then the entire register is shifted to the right and the input bit becomes 1.&lt;/p&gt;</description>
    </item>
    <item>
      <title>PCIE TLP Header python serializer</title>
      <link>/posts/2022/10/pcie-tlp-header-python-serializer/</link>
      <pubDate>Wed, 05 Oct 2022 00:00:00 +0000</pubDate>
      <guid>/posts/2022/10/pcie-tlp-header-python-serializer/</guid>
      <description>&lt;p&gt;I always wanted to write scapy-like framework for PCIE TLP serialization and This is a quick and dirty prototype I wrote at 1 AM. So, Don&amp;rsquo;t judge me.&lt;/p&gt;&#xA;&lt;p&gt;The final output of the serializer would be as follows. basically, something similar to scapy or wireshark breakdown of header fields.&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;name:memwr32 size:96 &lt;span style=&#34;color:#a5d6ff&#34;&gt;0000000000000000000000100000000000000000100000001100000001111111100000000000000010010000000000000&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    name:hdr size:32 &lt;span style=&#34;color:#a5d6ff&#34;&gt;000000000000000000000010000000000&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        name:RESERVED size:1 &lt;span style=&#34;color:#a5d6ff&#34;&gt;0&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        name:FMT size:2 &lt;span style=&#34;color:#a5d6ff&#34;&gt;00&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        name:TYPE size:5 &lt;span style=&#34;color:#a5d6ff&#34;&gt;00000&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        name:RESERVED size:1 &lt;span style=&#34;color:#a5d6ff&#34;&gt;0&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        name:TC size:3 &lt;span style=&#34;color:#a5d6ff&#34;&gt;000&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        name:RESERVED size:4 &lt;span style=&#34;color:#a5d6ff&#34;&gt;0000&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        name:TD size:1 &lt;span style=&#34;color:#a5d6ff&#34;&gt;0&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        name:EP size:1 &lt;span style=&#34;color:#a5d6ff&#34;&gt;0&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        name:ATTR size:2 &lt;span style=&#34;color:#a5d6ff&#34;&gt;00&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        name:AT size:2 &lt;span style=&#34;color:#a5d6ff&#34;&gt;00&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        name:LENGTH size:10 &lt;span style=&#34;color:#a5d6ff&#34;&gt;10000000000&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    name:requestID size:16 &lt;span style=&#34;color:#a5d6ff&#34;&gt;0000000100000001&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        name:BUS size:8 &lt;span style=&#34;color:#a5d6ff&#34;&gt;00000001&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        name:DEVICE size:4 &lt;span style=&#34;color:#a5d6ff&#34;&gt;0000&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        name:FUNCTION size:4 &lt;span style=&#34;color:#a5d6ff&#34;&gt;0001&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    name:TAG size:8 &lt;span style=&#34;color:#a5d6ff&#34;&gt;10000000&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    name:LASTDWBE size:4 &lt;span style=&#34;color:#a5d6ff&#34;&gt;1111&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    name:STDWBE size:4 &lt;span style=&#34;color:#a5d6ff&#34;&gt;1111&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    name:ADDR size:32 &lt;span style=&#34;color:#a5d6ff&#34;&gt;00000000000000010010000000000000&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The PCIE TLP (Tranaction Layer Packet) header depends on type of transaction: Memory, I/O, Configuration, and Messages. Also, there is routing type which depends on type of transaction:&lt;/p&gt;</description>
    </item>
    <item>
      <title>iwlwifi driver crash - The problem and workaround</title>
      <link>/posts/2022/08/iwlwifi-driver-crash-the-problem-and-workaround/</link>
      <pubDate>Sat, 27 Aug 2022 00:00:00 +0000</pubDate>
      <guid>/posts/2022/08/iwlwifi-driver-crash-the-problem-and-workaround/</guid>
      <description>&lt;p&gt;iwlwifi has been crashing a lot on me recently and it is driving me crazy because the only way to fix it is rebooting. The errors indicate that crash happens while NIC is waking up. I am currently using 5.4 kernel and i will see if updating the new version fixes it. At this point, I managed to produce the crash and test a workaround without rebooting.&lt;/p&gt;&#xA;&lt;h1 id=&#34;the-problem&#34;&gt;&#xA;  The problem&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#the-problem&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;Link to heading&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;Link to heading&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p&gt;Starting with  dmesg errors&lt;/p&gt;</description>
    </item>
    <item>
      <title>PCIe SRIOV linux initialization</title>
      <link>/posts/2022/08/pcie-sriov-linux-initialization/</link>
      <pubDate>Sat, 27 Aug 2022 00:00:00 +0000</pubDate>
      <guid>/posts/2022/08/pcie-sriov-linux-initialization/</guid>
      <description>&lt;p&gt;single root input/output virtualization (SR-IOV) is PCIe specifications that provide virtual function (in this context, the usual PCIe function would be physical function). virtual function is used VM for better performance. It allows flow the data like physical function with limited capabilities.&lt;/p&gt;&#xA;&lt;h1 id=&#34;finding-sriov-capabilities-space&#34;&gt;&#xA;  Finding SRIOV capabilities space&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#finding-sriov-capabilities-space&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;Link to heading&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;Link to heading&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#a5d6ff&#34;&gt;897&lt;/span&gt; &lt;span style=&#34;color:#ff7b72&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#d2a8ff;font-weight:bold&#34;&gt;pci_iov_init&lt;/span&gt;(&lt;span style=&#34;color:#ff7b72&#34;&gt;struct&lt;/span&gt; pci_dev &lt;span style=&#34;color:#ff7b72;font-weight:bold&#34;&gt;*&lt;/span&gt;dev)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#a5d6ff&#34;&gt;898&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#a5d6ff&#34;&gt;899&lt;/span&gt;     &lt;span style=&#34;color:#ff7b72&#34;&gt;int&lt;/span&gt; pos;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#a5d6ff&#34;&gt;900&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#a5d6ff&#34;&gt;901&lt;/span&gt;     &lt;span style=&#34;color:#ff7b72&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#ff7b72;font-weight:bold&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color:#d2a8ff;font-weight:bold&#34;&gt;pci_is_pcie&lt;/span&gt;(dev))&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#a5d6ff&#34;&gt;902&lt;/span&gt;         &lt;span style=&#34;color:#ff7b72&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff7b72;font-weight:bold&#34;&gt;-&lt;/span&gt;ENODEV;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#a5d6ff&#34;&gt;903&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#a5d6ff&#34;&gt;904&lt;/span&gt;     pos &lt;span style=&#34;color:#ff7b72;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#d2a8ff;font-weight:bold&#34;&gt;pci_find_ext_capability&lt;/span&gt;(dev, PCI_EXT_CAP_ID_SRIOV);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#a5d6ff&#34;&gt;905&lt;/span&gt;     &lt;span style=&#34;color:#ff7b72&#34;&gt;if&lt;/span&gt; (pos)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#a5d6ff&#34;&gt;906&lt;/span&gt;         &lt;span style=&#34;color:#ff7b72&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#d2a8ff;font-weight:bold&#34;&gt;sriov_init&lt;/span&gt;(dev, pos);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#a5d6ff&#34;&gt;907&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#a5d6ff&#34;&gt;908&lt;/span&gt;     &lt;span style=&#34;color:#ff7b72&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff7b72;font-weight:bold&#34;&gt;-&lt;/span&gt;ENODEV;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#a5d6ff&#34;&gt;909&lt;/span&gt; }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;pos&lt;/code&gt; is found by &lt;code&gt;pci_find_ext_capability&lt;/code&gt; which calls &lt;code&gt;pci_find_next_ext_capability&lt;/code&gt; to get the extended configuration capabilities with SRIOV ID. Note the comare at line 566.&lt;/p&gt;</description>
    </item>
    <item>
      <title>iwlwifi - Not The Hitchhiker&#39;s guide to intel wireless driver</title>
      <link>/posts/2022/08/iwlwifi-not-the-hitchhikers-guide-to-intel-wireless-driver/</link>
      <pubDate>Thu, 25 Aug 2022 00:00:00 +0000</pubDate>
      <guid>/posts/2022/08/iwlwifi-not-the-hitchhikers-guide-to-intel-wireless-driver/</guid>
      <description>&lt;p&gt;This is the second post in a series about &lt;code&gt;iwlwifi&lt;/code&gt; the linux intel wireless controller driver. Unlucky(or luck) me, this driver crashes randomly on my machine. I decided to debug the crash before giving up and bump up kernel and modules version. &lt;code&gt;iwlwifi&lt;/code&gt; is basically PCIe driver but it also interacts with network stack and network configuration stack.&lt;/p&gt;&#xA;&lt;h1 id=&#34;pcie-driver&#34;&gt;&#xA;  PCIe driver&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#pcie-driver&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;Link to heading&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;Link to heading&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p&gt;Starting with PCIe side, Drivers have to register with the PCIe subsystem and the PCIe core will iterate devices and match drivers to the devices.&lt;/p&gt;</description>
    </item>
    <item>
      <title>A 5 minute tour of my PCI wireless controller sysfs</title>
      <link>/posts/2022/08/a-5-minute-tour-of-my-pci-wireless-controller-sysfs/</link>
      <pubDate>Tue, 23 Aug 2022 00:00:00 +0000</pubDate>
      <guid>/posts/2022/08/a-5-minute-tour-of-my-pci-wireless-controller-sysfs/</guid>
      <description>&lt;p&gt;It started with me trying to debug &lt;code&gt;iwlwifi&lt;/code&gt; kernel panic which brings down the network interface. So, I thought to write some stuff about the controller itself.&lt;/p&gt;&#xA;&lt;p&gt;Starting with &lt;code&gt;lspci&lt;/code&gt; output which basically reads sysfs (that would be /sys, more about sysfs in another post).&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ lspci -s 0000:03:00.0  -v&#xA;03:00.0 Network controller: Intel Corporation Dual Band Wireless-AC 3165 Plus Bluetooth (rev 99)&#xA;&#x9;Subsystem: Intel Corporation Dual Band Wireless-AC 3165 Plus Bluetooth&#xA;&#x9;Flags: bus master, fast devsel, latency 0, IRQ 125&#xA;&#x9;Memory at 91000000 (64-bit, non-prefetchable) [size=8K]&#xA;&#x9;Capabilities: &amp;lt;access denied&amp;gt;&#xA;&#x9;Kernel driver in use: iwlwifi&#xA;&#x9;Kernel modules: iwlwifi&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Well, I can see all the information at &lt;code&gt;/sys/bus/pci/devices/0000:03:00.0&lt;/code&gt; anyway, but lspci is nicer to look at. So, what is &amp;lsquo;0000:03:00.0&amp;rsquo;?&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
