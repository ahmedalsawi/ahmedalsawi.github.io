<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Qemu on Techiedeepdive</title>
    <link>/tags/qemu/</link>
    <description>Recent content in Qemu on Techiedeepdive</description>
    <generator>Hugo</generator>
    <language>en</language>
    <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
    <lastBuildDate>Sun, 01 Jun 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="/tags/qemu/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Qemu - Network Networking interface -nic</title>
      <link>/posts/2025/06/qemu-network-networking-interface-nic/</link>
      <pubDate>Sun, 01 Jun 2025 00:00:00 +0000</pubDate>
      <guid>/posts/2025/06/qemu-network-networking-interface-nic/</guid>
      <description>&lt;p&gt;This post is about Qemu &lt;code&gt;-nic&lt;/code&gt;. Qemu uses several networking options such as SLIRP, TAP or bridge (those the ones I tried anyway).&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;-nic&lt;/code&gt; replaces &lt;code&gt;-net&lt;/code&gt; and combines the functionality of &lt;code&gt;-device&lt;/code&gt; and &lt;code&gt;-netdev&lt;/code&gt;. &lt;code&gt;-nic&lt;/code&gt; takes the backend and device type to choose the network configuration between host and guest.&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-nic &amp;lt;backend&amp;gt;,&amp;lt;parameters&amp;gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;user-mode&#34;&gt;&#xA;  User mode&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#user-mode&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;Link to heading&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;Link to heading&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p&gt;Also known as SLIRP. This allows VM to access the internet through NAT provided by the host. In this mode, the gust is not accessible from the host (unless port forwarding is enabled).&lt;/p&gt;</description>
    </item>
    <item>
      <title>Qemu riscv emulation - spike machine</title>
      <link>/posts/2024/05/qemu-riscv-emulation-spike-machine/</link>
      <pubDate>Sat, 25 May 2024 00:00:00 +0000</pubDate>
      <guid>/posts/2024/05/qemu-riscv-emulation-spike-machine/</guid>
      <description>&lt;p&gt;This is a deepdive into how qemu does riscv spike board emulation . Starting with &lt;code&gt;spike_machine_class_init&lt;/code&gt; registers &lt;code&gt;spike_board_init&lt;/code&gt; with the machine type.&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ff7b72&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#ff7b72&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#d2a8ff;font-weight:bold&#34;&gt;spike_machine_class_init&lt;/span&gt;(ObjectClass &lt;span style=&#34;color:#ff7b72;font-weight:bold&#34;&gt;*&lt;/span&gt;oc, &lt;span style=&#34;color:#ff7b72&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#ff7b72;font-weight:bold&#34;&gt;*&lt;/span&gt;data)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    MachineClass &lt;span style=&#34;color:#ff7b72;font-weight:bold&#34;&gt;*&lt;/span&gt;mc &lt;span style=&#34;color:#ff7b72;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#d2a8ff;font-weight:bold&#34;&gt;MACHINE_CLASS&lt;/span&gt;(oc);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    mc&lt;span style=&#34;color:#ff7b72;font-weight:bold&#34;&gt;-&amp;gt;&lt;/span&gt;desc &lt;span style=&#34;color:#ff7b72;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a5d6ff&#34;&gt;&amp;#34;RISC-V Spike board&amp;#34;&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    mc&lt;span style=&#34;color:#ff7b72;font-weight:bold&#34;&gt;-&amp;gt;&lt;/span&gt;init &lt;span style=&#34;color:#ff7b72;font-weight:bold&#34;&gt;=&lt;/span&gt; spike_board_init;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    mc&lt;span style=&#34;color:#ff7b72;font-weight:bold&#34;&gt;-&amp;gt;&lt;/span&gt;max_cpus &lt;span style=&#34;color:#ff7b72;font-weight:bold&#34;&gt;=&lt;/span&gt; SPIKE_CPUS_MAX;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    mc&lt;span style=&#34;color:#ff7b72;font-weight:bold&#34;&gt;-&amp;gt;&lt;/span&gt;is_default &lt;span style=&#34;color:#ff7b72;font-weight:bold&#34;&gt;=&lt;/span&gt; true;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    mc&lt;span style=&#34;color:#ff7b72;font-weight:bold&#34;&gt;-&amp;gt;&lt;/span&gt;default_cpu_type &lt;span style=&#34;color:#ff7b72;font-weight:bold&#34;&gt;=&lt;/span&gt; TYPE_RISCV_CPU_BASE;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    mc&lt;span style=&#34;color:#ff7b72;font-weight:bold&#34;&gt;-&amp;gt;&lt;/span&gt;possible_cpu_arch_ids &lt;span style=&#34;color:#ff7b72;font-weight:bold&#34;&gt;=&lt;/span&gt; riscv_numa_possible_cpu_arch_ids;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    mc&lt;span style=&#34;color:#ff7b72;font-weight:bold&#34;&gt;-&amp;gt;&lt;/span&gt;cpu_index_to_instance_props &lt;span style=&#34;color:#ff7b72;font-weight:bold&#34;&gt;=&lt;/span&gt; riscv_numa_cpu_index_to_props;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    mc&lt;span style=&#34;color:#ff7b72;font-weight:bold&#34;&gt;-&amp;gt;&lt;/span&gt;get_default_cpu_node_id &lt;span style=&#34;color:#ff7b72;font-weight:bold&#34;&gt;=&lt;/span&gt; riscv_numa_get_default_cpu_node_id;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    mc&lt;span style=&#34;color:#ff7b72;font-weight:bold&#34;&gt;-&amp;gt;&lt;/span&gt;numa_mem_supported &lt;span style=&#34;color:#ff7b72;font-weight:bold&#34;&gt;=&lt;/span&gt; true;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    mc&lt;span style=&#34;color:#ff7b72;font-weight:bold&#34;&gt;-&amp;gt;&lt;/span&gt;default_ram_id &lt;span style=&#34;color:#ff7b72;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a5d6ff&#34;&gt;&amp;#34;riscv.spike.ram&amp;#34;&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ff7b72&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#ff7b72&#34;&gt;const&lt;/span&gt; TypeInfo spike_machine_typeinfo &lt;span style=&#34;color:#ff7b72;font-weight:bold&#34;&gt;=&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .name       &lt;span style=&#34;color:#ff7b72;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#d2a8ff;font-weight:bold&#34;&gt;MACHINE_TYPE_NAME&lt;/span&gt;(&lt;span style=&#34;color:#a5d6ff&#34;&gt;&amp;#34;spike&amp;#34;&lt;/span&gt;),&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .parent     &lt;span style=&#34;color:#ff7b72;font-weight:bold&#34;&gt;=&lt;/span&gt; TYPE_MACHINE,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .class_init &lt;span style=&#34;color:#ff7b72;font-weight:bold&#34;&gt;=&lt;/span&gt; spike_machine_class_init,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .instance_init &lt;span style=&#34;color:#ff7b72;font-weight:bold&#34;&gt;=&lt;/span&gt; spike_machine_instance_init,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .instance_size &lt;span style=&#34;color:#ff7b72;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ff7b72&#34;&gt;sizeof&lt;/span&gt;(SpikeState),&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In &lt;code&gt;spike_board_init&lt;/code&gt;, the board are create&lt;/p&gt;</description>
    </item>
    <item>
      <title>Qemu - Data object exchange DOE</title>
      <link>/posts/2023/04/qemu-data-object-exchange-doe/</link>
      <pubDate>Sat, 01 Apr 2023 00:00:00 +0000</pubDate>
      <guid>/posts/2023/04/qemu-data-object-exchange-doe/</guid>
      <description>&lt;p&gt;This is a quick write-up about Qemu DOE emulation. DOE is part of PCIe and CXL extended capabilities. Technically, It&amp;rsquo;s optional but is important part of IDE starting gen5.&lt;/p&gt;&#xA;&lt;p&gt;Starting with &lt;code&gt;cxl_usp_read_config&lt;/code&gt; is one of the places where &lt;code&gt;pcie_doe_read_config&lt;/code&gt; is called. It seems it&amp;rsquo;s only supported with CXL which kinda matches what kernel implements. If it&amp;rsquo;s DOE extended address, it will fall back to &lt;code&gt;pci_default_read_config&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ff7b72&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#ff7b72&#34;&gt;uint32_t&lt;/span&gt; &lt;span style=&#34;color:#d2a8ff;font-weight:bold&#34;&gt;cxl_usp_read_config&lt;/span&gt;(PCIDevice &lt;span style=&#34;color:#ff7b72;font-weight:bold&#34;&gt;*&lt;/span&gt;d, &lt;span style=&#34;color:#ff7b72&#34;&gt;uint32_t&lt;/span&gt; address, &lt;span style=&#34;color:#ff7b72&#34;&gt;int&lt;/span&gt; len)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    CXLUpstreamPort &lt;span style=&#34;color:#ff7b72;font-weight:bold&#34;&gt;*&lt;/span&gt;usp &lt;span style=&#34;color:#ff7b72;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#d2a8ff;font-weight:bold&#34;&gt;CXL_USP&lt;/span&gt;(d);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#ff7b72&#34;&gt;uint32_t&lt;/span&gt; val;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#ff7b72&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#d2a8ff;font-weight:bold&#34;&gt;pcie_doe_read_config&lt;/span&gt;(&lt;span style=&#34;color:#ff7b72;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;usp&lt;span style=&#34;color:#ff7b72;font-weight:bold&#34;&gt;-&amp;gt;&lt;/span&gt;doe_cdat, address, len, &lt;span style=&#34;color:#ff7b72;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;val)) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#ff7b72&#34;&gt;return&lt;/span&gt; val;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#ff7b72&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#d2a8ff;font-weight:bold&#34;&gt;pci_default_read_config&lt;/span&gt;(d, address, len);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;pcie_doe_read_config&lt;/code&gt; reads the fields when address matches the DW in DOW extended configuration address space. Other than configuration access, The important thing here is reading/writing from &lt;code&gt;read_mbox&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Qemu - PCIe SRIOV and virtual function</title>
      <link>/posts/2023/04/qemu-pcie-sriov-and-virtual-function/</link>
      <pubDate>Sat, 01 Apr 2023 00:00:00 +0000</pubDate>
      <guid>/posts/2023/04/qemu-pcie-sriov-and-virtual-function/</guid>
      <description>&lt;p&gt;This is a quick write-up about SRIOV and virtual functions emulation in Qemu. From &lt;a href=&#34;https://docs.vmware.com/en/VMware-vSphere/7.0/com.vmware.vsphere.networking.doc/GUID-CC021803-30EA-444D-BCBE-618E0D836B9F.html&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;link&lt;/a&gt;&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;SR-IOV is a specification that allows a single Peripheral Component Interconnect Express (PCIe) physical device under a single root port to appear as multiple separate physical devices to the hypervisor or the guest operating system.&lt;/p&gt;&#xA;&lt;p&gt;SR-IOV uses physical functions (PFs) and virtual functions (VFs) to manage global functions for the SR-IOV devices. PFs are full PCIe functions that are capable of configuring and managing the SR-IOV functionality. It is possible to configure or control PCIe devices using PFs, and the PF has full ability to move data in and out of the device. VFs are lightweight PCIe functions that support data flowing but have a restricted set of configuration resources.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Qemu riscv emulation - virt machine</title>
      <link>/posts/2023/03/qemu-riscv-emulation-virt-machine/</link>
      <pubDate>Fri, 31 Mar 2023 00:00:00 +0000</pubDate>
      <guid>/posts/2023/03/qemu-riscv-emulation-virt-machine/</guid>
      <description>&lt;p&gt;This is a quick write-up on qemu riscv emulation. Qemu provides several APIs to create user defined boards(in qemu lingo, it&amp;rsquo;s called machine) and devices in this board.&lt;/p&gt;&#xA;&lt;h1 id=&#34;risc-virt-board&#34;&gt;&#xA;  risc virt Board&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#risc-virt-board&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;Link to heading&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;Link to heading&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p&gt;&lt;code&gt;virt&lt;/code&gt; machine is a basic machine to run riscv code with VIRTIO MMIO&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;RISC-V machine with 16550a UART and VirtIO MMIO&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;In &lt;code&gt;hw/riscv/virt.c&lt;/code&gt;, The initialization code for the virt machine. &lt;code&gt;virt_machine_typeinfo&lt;/code&gt; registers the type with qemu QOM using function &lt;code&gt;virt_machine_class_init&lt;/code&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Qemu PCIe Emulation</title>
      <link>/posts/2023/03/qemu-pcie-emulation/</link>
      <pubDate>Sun, 19 Mar 2023 00:00:00 +0000</pubDate>
      <guid>/posts/2023/03/qemu-pcie-emulation/</guid>
      <description>&lt;p&gt;This post is about how qemu emulates PCI devices for guest Kernel. Honestly, I took the scenic road here which is reading the code and setting breakpoints in GDB at interesting places and work my way through the stack trace. Disclaimer, This is a very short post on a complicated topic and huge code base(Qemu). But It&amp;rsquo;s a good start to dig deeper into qemu code (more specifically PCI emulation in qemu)&lt;/p&gt;</description>
    </item>
    <item>
      <title>Boot linux in Qemu</title>
      <link>/posts/2019/05/boot-linux-in-qemu/</link>
      <pubDate>Sat, 11 May 2019 00:00:00 +0000</pubDate>
      <guid>/posts/2019/05/boot-linux-in-qemu/</guid>
      <description>&lt;p&gt;This is quick guide to compile linux kernel and minimal boot in Qemu.&lt;/p&gt;&#xA;&lt;h1 id=&#34;compiling-linux-kernel&#34;&gt;&#xA;  Compiling linux kernel&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#compiling-linux-kernel&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;Link to heading&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;Link to heading&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p&gt;To compile linux kernel, you will need &lt;code&gt;.config&lt;/code&gt; to configure the build. To generate default &lt;code&gt;.config&lt;/code&gt;:&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;make defconfig&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;if you are planning to upgrade the kernel version on your machine, you need to use the current config to generate compatible configuration&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;cp /boot/config-&lt;span style=&#34;color:#a5d6ff&#34;&gt;`&lt;/span&gt;kernel version&lt;span style=&#34;color:#a5d6ff&#34;&gt;`&lt;/span&gt; ./config&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;make oldconfig&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;creating-busybox-initramfs&#34;&gt;&#xA;  Creating busybox initramfs&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#creating-busybox-initramfs&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;Link to heading&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;Link to heading&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p&gt;&lt;code&gt;mkinitramfs&lt;/code&gt; creates minimal busybox file system with busybox unix commands.&#xA;More importantly, the kernel will try to mount root file system by default.So, you will get kernel panic if kernel didn&amp;rsquo;t find one.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
