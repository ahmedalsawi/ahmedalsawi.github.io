<!DOCTYPE html>
<html lang="en">

<head>
  <title>
  Dijkstra Algorithm · Techiedeepdive
</title>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="color-scheme" content="light dark">




<meta name="description" content="Introduction  Link to heading   Dijkstra&rsquo;s algorithm says it is an algorithm for finding the shortest paths between nodes in a graph.
Dijkstra is big deal because it&rsquo;s used to find the best way (based on weight function) between points A and B on a graph. It works well on graphs with non-negative edges.
Considering the instance of the problem where A and B is connected and graph and required to calculate minimum cost for that path.">
<meta name="keywords" content="">

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content=""/>

<meta name="twitter:title" content="Dijkstra Algorithm"/>
<meta name="twitter:description" content="Introduction  Link to heading   Dijkstra&rsquo;s algorithm says it is an algorithm for finding the shortest paths between nodes in a graph.
Dijkstra is big deal because it&rsquo;s used to find the best way (based on weight function) between points A and B on a graph. It works well on graphs with non-negative edges.
Considering the instance of the problem where A and B is connected and graph and required to calculate minimum cost for that path."/>

<meta property="og:title" content="Dijkstra Algorithm" />
<meta property="og:description" content="Introduction  Link to heading   Dijkstra&rsquo;s algorithm says it is an algorithm for finding the shortest paths between nodes in a graph.
Dijkstra is big deal because it&rsquo;s used to find the best way (based on weight function) between points A and B on a graph. It works well on graphs with non-negative edges.
Considering the instance of the problem where A and B is connected and graph and required to calculate minimum cost for that path." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/2020/06/dijkstra-algorithm/" /><meta property="og:image" content=""/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-06-10T22:04:46+02:00" />
<meta property="article:modified_time" content="2020-06-10T22:04:46+02:00" /><meta property="og:site_name" content="Techiedeepdive" />





<link rel="canonical" href="/posts/2020/06/dijkstra-algorithm/">


<link rel="preload" href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as="font" type="font/woff2" crossorigin>


  
  
  <link rel="stylesheet" href="/css/coder.min.0669b62fc2c181a12a4ba10be9984e385c9a5e83dc7cb7ae3759ad0b98d7e8b2.css" integrity="sha256-Bmm2L8LBgaEqS6EL6ZhOOFyaXoPcfLeuN1mtC5jX6LI=" crossorigin="anonymous" media="screen" />






  
    
    
    <link rel="stylesheet" href="/css/coder-dark.min.f6534b0b446b75d9b6ad77a97d43ede2ddaeff1b6e2361fb7198d6f8fcb7f83f.css" integrity="sha256-9lNLC0Rrddm2rXepfUPt4t2u/xtuI2H7cZjW&#43;Py3&#43;D8=" crossorigin="anonymous" media="screen" />
  



 




<link rel="icon" type="image/png" href="/images/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/images/favicon-16x16.png" sizes="16x16">

<link rel="apple-touch-icon" href="/images/apple-touch-icon.png">
<link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">




<meta name="generator" content="Hugo 0.92.2" />





</head>






<body class="preload-transitions colorscheme-auto">
  
<div class="float-container">
    <a id="dark-mode-toggle" class="colorscheme-toggle">
        <i class="fa fa-adjust fa-fw" aria-hidden="true"></i>
    </a>
</div>


  <main class="wrapper">
    <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="/">
      Techiedeepdive
    </a>
    
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link" href="/posts">Blog</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/reading-list/">Reading list</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/tags/">Tags</a>
            </li>
          
        
        
      </ul>
    
  </section>
</nav>


    <div class="content">
      
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">
            <a class="title-link" href="/posts/2020/06/dijkstra-algorithm/">
              Dijkstra Algorithm
            </a>
          </h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fa fa-calendar" aria-hidden="true"></i>
              <time datetime="2020-06-10T22:04:46&#43;02:00">
                June 10, 2020
              </time>
            </span>
            <span class="reading-time">
              <i class="fa fa-clock-o" aria-hidden="true"></i>
              4-minute read
            </span>
          </div>
          
          
          <div class="tags">
  <i class="fa fa-tag" aria-hidden="true"></i>
    <span class="tag">
      <a href="/tags/graphs/">Graphs</a>
    </span></div>

        </div>
      </header>

      <div class="post-content">
        
        <h1 id="introduction">
  Introduction
  <a class="heading-link" href="#introduction">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h1>
<p><a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm"  class="external-link" target="_blank" rel="noopener">Dijkstra&rsquo;s algorithm</a> says it is an algorithm for finding the shortest paths between nodes in a graph.</p>
<p>Dijkstra is big deal because it&rsquo;s used to find the best way (based on weight function) between points A and B on a graph. It works well on graphs with non-negative edges.</p>
<p>Considering the instance of the problem where A and B is connected and graph and required to calculate minimum cost for that path.</p>
<h1 id="algorithm">
  Algorithm
  <a class="heading-link" href="#algorithm">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h1>
<p>I used the same exact algorithm as wiki page.</p>
<ul>
<li>Mark all nodes unvisited. Create a set of all the unvisited nodes called the unvisited set.
Assign to every node a tentative distance value: set it to zero for our initial node and to infinity for all other nodes. Set the initial node as current.[14]</li>
<li>For the current node, consider all of its unvisited neighbours and calculate their tentative distances through the current node. Compare the newly calculated tentative distance to the current assigned value and assign the smaller one. For example, if the current node A is marked with a distance of 6, and the edge connecting it with a neighbour B has length 2, then the distance to B through A will be 6 + 2 = 8. If B was previously marked with a distance greater than 8 then change it to 8. Otherwise, the current value will be kept.</li>
<li>When we are done considering all of the unvisited neighbours of the current node, mark the current node as visited and remove it from the unvisited set. A visited node will never be checked again.</li>
<li>If the destination node has been marked visited (when planning a route between two specific nodes) or if the smallest tentative distance among the nodes in the unvisited set is infinity (when planning a complete traversal; occurs when there is no connection between the initial node and remaining unvisited nodes), then stop. The algorithm has finished.</li>
<li>Otherwise, select the unvisited node that is marked with the smallest tentative distance, set it as the new &ldquo;current node&rdquo;, and go back to step 3.</li>
</ul>
<p>There is variant where it&rsquo;s need to calculate minimum distance to all nodes. It&rsquo;s essentially the same steps but the condition for search termination will be that all nodes are visited instead of the destination node.</p>
<h1 id="implementation">
  Implementation
  <a class="heading-link" href="#implementation">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h1>
<ul>
<li>I used adjacency list to represent the graph.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">    <span style="color:#fff;font-weight:bold">def</span> __init__(self, V):
        self.V = V
        self.graph = [[] <span style="color:#fff;font-weight:bold">for</span> i in <span style="color:#fff;font-weight:bold">range</span>(V)]

    <span style="color:#fff;font-weight:bold">def</span> connect(self, n1,n2, w):
        self.graph[n1].append((n2,w))
        self.graph[n2].append((n1,w))
</code></pre></div><ul>
<li>
<p>The algorithm says <em>inf</em> as initial distance to all nodes. I initially used -1 to represent inf but i complicated the comparisons. but i found out python have <code>float('inf')</code> which works fine in arithmetic operations.</p>
</li>
<li>
<p>The shortest path between two points and shortest path spanning tree(shortest path to all nodes) is the same. the only difference is the termination condition. For two points, i just need to check the destination node was visited.</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">
            <span style="color:#007f7f"># check for algorithm termination and calculate the new &#34;current&#34;</span>
            <span style="color:#fff;font-weight:bold">if</span> n2 is <span style="color:#fff;font-weight:bold">None</span>:
                run =  (<span style="color:#fff;font-weight:bold">True</span> in unvisited) 
            <span style="color:#fff;font-weight:bold">else</span>:
                run = (unvisited[n2] == <span style="color:#fff;font-weight:bold">True</span>)
</code></pre></div><h1 id="putting-it-all-together">
  Putting it all together
  <a class="heading-link" href="#putting-it-all-together">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h1>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">
<span style="color:#fff;font-weight:bold">class</span> Dijkstra:
    <span style="color:#0ff;font-weight:bold">&#34;&#34;&#34;
</span><span style="color:#0ff;font-weight:bold">    Implementation based on algorithm in 
</span><span style="color:#0ff;font-weight:bold">    https://en.wikipedia.org/wiki/Dijkstra</span><span style="color:#0ff;font-weight:bold">%27s</span><span style="color:#0ff;font-weight:bold">_algorithm
</span><span style="color:#0ff;font-weight:bold">    &#34;&#34;&#34;</span>
    <span style="color:#fff;font-weight:bold">def</span> __init__(self, V):
        self.V = V
        self.graph = [[] <span style="color:#fff;font-weight:bold">for</span> i in <span style="color:#fff;font-weight:bold">range</span>(V)]

    <span style="color:#fff;font-weight:bold">def</span> connect(self, n1,n2, w):
        self.graph[n1].append((n2,w))
        self.graph[n2].append((n1,w))

    <span style="color:#fff;font-weight:bold">def</span> shortestPath(self, n1, n2=<span style="color:#fff;font-weight:bold">None</span>):
        unvisited = [<span style="color:#fff;font-weight:bold">True</span>] * self.V

        distance = [ <span style="color:#fff;font-weight:bold">float</span>(<span style="color:#0ff;font-weight:bold">&#39;inf&#39;</span>) ] * self.V
        distance[n1] = <span style="color:#ff0;font-weight:bold">0</span>

        current = n1

        run  = <span style="color:#fff;font-weight:bold">True</span>
        <span style="color:#fff;font-weight:bold">while</span> run:
            <span style="color:#007f7f">#print(f&#34;&gt;&gt;&gt;&gt; current={current}&#34;)</span>
            <span style="color:#007f7f"># iterate the neighbours</span>
            <span style="color:#fff;font-weight:bold">for</span> neighbour in self.graph[current]:
                (n,w) = neighbour

                <span style="color:#fff;font-weight:bold">if</span> unvisited[n]:
                    <span style="color:#007f7f"># Loop over neighbours</span>
                    <span style="color:#007f7f">#print(f&#34;    &gt;&gt;&gt;&gt; neighbour={n} weight={w}&#34;)</span>
                    new_dist = distance[current] + w

                    <span style="color:#fff;font-weight:bold">if</span>  new_dist &lt; distance[n]:
                        <span style="color:#007f7f">#print(f&#34;        &gt;&gt;&gt;&gt; updated distance {new_dist}&#34;)</span>
                        distance[n] = new_dist
                    
            unvisited[current] = <span style="color:#fff;font-weight:bold">False</span>

            <span style="color:#007f7f"># check for algorithm termination and calculate the new &#34;current&#34;</span>
            <span style="color:#fff;font-weight:bold">if</span> n2 is <span style="color:#fff;font-weight:bold">None</span>:
                run =  (<span style="color:#fff;font-weight:bold">True</span> in unvisited) 
            <span style="color:#fff;font-weight:bold">else</span>:
                run = (unvisited[n2] == <span style="color:#fff;font-weight:bold">True</span>)
            
            value = <span style="color:#fff;font-weight:bold">float</span>(<span style="color:#0ff;font-weight:bold">&#39;inf&#39;</span>)
            <span style="color:#fff;font-weight:bold">for</span> v in <span style="color:#fff;font-weight:bold">range</span>(self.V):
                <span style="color:#fff;font-weight:bold">if</span> distance[v] &lt; value and unvisited[v] == <span style="color:#fff;font-weight:bold">True</span>:
                    value = distance[v]
                    n_current = v
            
            current = n_current

        <span style="color:#fff;font-weight:bold">print</span>(distance)
            

<span style="color:#fff;font-weight:bold">def</span> main():
    g = Dijkstra(<span style="color:#ff0;font-weight:bold">9</span>)
    g.connect(<span style="color:#ff0;font-weight:bold">0</span>,<span style="color:#ff0;font-weight:bold">1</span>,<span style="color:#ff0;font-weight:bold">4</span>)
    g.connect(<span style="color:#ff0;font-weight:bold">0</span>,<span style="color:#ff0;font-weight:bold">7</span>,<span style="color:#ff0;font-weight:bold">8</span>)
    g.connect(<span style="color:#ff0;font-weight:bold">1</span>,<span style="color:#ff0;font-weight:bold">7</span>,<span style="color:#ff0;font-weight:bold">11</span>)
    g.connect(<span style="color:#ff0;font-weight:bold">1</span>,<span style="color:#ff0;font-weight:bold">2</span>,<span style="color:#ff0;font-weight:bold">8</span>)
    g.connect(<span style="color:#ff0;font-weight:bold">7</span>,<span style="color:#ff0;font-weight:bold">8</span>,<span style="color:#ff0;font-weight:bold">7</span>)
    g.connect(<span style="color:#ff0;font-weight:bold">7</span>,<span style="color:#ff0;font-weight:bold">6</span>,<span style="color:#ff0;font-weight:bold">1</span>)
    g.connect(<span style="color:#ff0;font-weight:bold">2</span>,<span style="color:#ff0;font-weight:bold">8</span>,<span style="color:#ff0;font-weight:bold">2</span>)
    g.connect(<span style="color:#ff0;font-weight:bold">2</span>,<span style="color:#ff0;font-weight:bold">5</span>,<span style="color:#ff0;font-weight:bold">4</span>)
    g.connect(<span style="color:#ff0;font-weight:bold">2</span>,<span style="color:#ff0;font-weight:bold">3</span>,<span style="color:#ff0;font-weight:bold">7</span>)
    g.connect(<span style="color:#ff0;font-weight:bold">8</span>,<span style="color:#ff0;font-weight:bold">6</span>,<span style="color:#ff0;font-weight:bold">6</span>)
    g.connect(<span style="color:#ff0;font-weight:bold">6</span>,<span style="color:#ff0;font-weight:bold">5</span>,<span style="color:#ff0;font-weight:bold">2</span>)
    g.connect(<span style="color:#ff0;font-weight:bold">3</span>,<span style="color:#ff0;font-weight:bold">5</span>,<span style="color:#ff0;font-weight:bold">14</span>)
    g.connect(<span style="color:#ff0;font-weight:bold">3</span>,<span style="color:#ff0;font-weight:bold">4</span>,<span style="color:#ff0;font-weight:bold">9</span>)
    g.connect(<span style="color:#ff0;font-weight:bold">5</span>,<span style="color:#ff0;font-weight:bold">4</span>,<span style="color:#ff0;font-weight:bold">10</span>)
    g.shortestPath(<span style="color:#ff0;font-weight:bold">0</span>,<span style="color:#ff0;font-weight:bold">7</span>)
    
    g.shortestPath(<span style="color:#ff0;font-weight:bold">0</span>)
    g.shortestPath(<span style="color:#ff0;font-weight:bold">1</span>)
<span style="color:#fff;font-weight:bold">if</span> __name__ == <span style="color:#0ff;font-weight:bold">&#34;__main__&#34;</span>:
    main()
</code></pre></div>
      </div>


      <footer>
        


        
        
        
        
      </footer>
    </article>

    
  </section>

    </div>

    <footer class="footer">
  <section class="container">
    ©
    
    2023
    
    ·
    
    Powered by <a href="https://gohugo.io/">Hugo</a> & <a href="https://github.com/luizdepra/hugo-coder/">Coder</a>.
    
  </section>
</footer>

  </main>

  

  
  
  <script src="/js/coder.min.369d90111ae4409b4e51de5efd23a46b92663fcc82dc9a0efde7f70bffc3f949.js" integrity="sha256-Np2QERrkQJtOUd5e/SOka5JmP8yC3JoO/ef3C//D&#43;Uk="></script>
  

  

  


  

  

  

  

  

  

  

  

  

  

  

  
</body>

</html>