<!DOCTYPE html>
<html lang="en">

<head>
  <title>
  Merkle Tree · Techiedeepdive
</title>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="color-scheme" content="light dark">




<meta name="description" content="Merkle tree is hash tree (usually binary tree) where each node is hash function of children nodes.
i used binary tree with sha256 from hashlib.

  Building the tree
  
    
    Link to heading
  

i choose to start from the leafs and build up the tree bottom-to-top. _buildTree does that by the recursively building parent nodes. for uniformity, i chose to add padding node to the tree (with empty hash string). this way the nodes are always even number all the way to the root node. this means unneeded nodes but easier logic. I didn&rsquo;t put much thought about the upper limit for the number of dummy nodes.">
<meta name="keywords" content="homepage, blog">



  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:image" content="/">
  <meta name="twitter:title" content="Merkle Tree">
  <meta name="twitter:description" content="Merkle tree is hash tree (usually binary tree) where each node is hash function of children nodes. i used binary tree with sha256 from hashlib.
Building the tree Link to heading i choose to start from the leafs and build up the tree bottom-to-top. _buildTree does that by the recursively building parent nodes. for uniformity, i chose to add padding node to the tree (with empty hash string). this way the nodes are always even number all the way to the root node. this means unneeded nodes but easier logic. I didn’t put much thought about the upper limit for the number of dummy nodes.">

<meta property="og:url" content="/posts/2020/05/merkle-tree/">
  <meta property="og:site_name" content="Techiedeepdive">
  <meta property="og:title" content="Merkle Tree">
  <meta property="og:description" content="Merkle tree is hash tree (usually binary tree) where each node is hash function of children nodes. i used binary tree with sha256 from hashlib.
Building the tree Link to heading i choose to start from the leafs and build up the tree bottom-to-top. _buildTree does that by the recursively building parent nodes. for uniformity, i chose to add padding node to the tree (with empty hash string). this way the nodes are always even number all the way to the root node. this means unneeded nodes but easier logic. I didn’t put much thought about the upper limit for the number of dummy nodes.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2020-05-29T23:04:23+02:00">
    <meta property="article:modified_time" content="2020-05-29T23:04:23+02:00">
    <meta property="article:tag" content="Crypto">
    <meta property="og:image" content="/">




<link rel="canonical" href="/posts/2020/05/merkle-tree/">


<link rel="preload" href="/fonts/fa-brands-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="/fonts/fa-regular-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="/fonts/fa-solid-900.woff2" as="font" type="font/woff2" crossorigin>


  
  
  <link rel="stylesheet" href="/css/coder.min.aa5ef26fa979d6793724ae2dbd71efa94fd16cb1c5c7db3b6651f21f9892a5fd.css" integrity="sha256-ql7yb6l51nk3JK4tvXHvqU/RbLHFx9s7ZlHyH5iSpf0=" crossorigin="anonymous" media="screen" />






  
    
    
    <link rel="stylesheet" href="/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css" integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin="anonymous" media="screen" />
  



 




<link rel="icon" type="image/svg+xml" href="/images/favicon.svg" sizes="any">
<link rel="icon" type="image/png" href="/images/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/images/favicon-16x16.png" sizes="16x16">

<link rel="apple-touch-icon" href="/images/apple-touch-icon.png">
<link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">









</head>






<body class="preload-transitions colorscheme-auto">
  
<div class="float-container">
    <a id="dark-mode-toggle" class="colorscheme-toggle">
        <i class="fa-solid fa-adjust fa-fw" aria-hidden="true"></i>
    </a>
</div>


  <main class="wrapper">
    <nav class="navigation">
  <section class="container">
    
    <a class="navigation-title" href="/">
      Techiedeepdive
    </a>
    
    
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa-solid fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link " href="/posts">Blog</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/reading-list/">Reading list</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/tags/">Tags</a>
            </li>
          
        
        
      </ul>
    
  </section>
</nav>


    <div class="content">
      
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">
            <a class="title-link" href="/posts/2020/05/merkle-tree/">
              Merkle Tree
            </a>
          </h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fa-solid fa-calendar" aria-hidden="true"></i>
              <time datetime="2020-05-29T23:04:23&#43;02:00">
                May 29, 2020
              </time>
            </span>
            <span class="reading-time">
              <i class="fa-solid fa-clock" aria-hidden="true"></i>
              4-minute read
            </span>
          </div>
          
          
          <div class="tags">
  <i class="fa-solid fa-tag" aria-hidden="true"></i>
    <span class="tag">
      <a href="/tags/crypto/">Crypto</a>
    </span></div>

        </div>
      </header>

      <div class="post-content">
        
        <p><a href="https://en.wikipedia.org/wiki/Merkle_tree"  class="external-link" target="_blank" rel="noopener">Merkle tree</a> is hash tree (usually binary tree) where each node is hash function of children nodes.
i used binary tree with sha256 from <code>hashlib</code>.</p>
<h1 id="building-the-tree">
  Building the tree
  <a class="heading-link" href="#building-the-tree">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h1>
<p>i choose to start from the leafs and build up the tree bottom-to-top. <code>_buildTree</code> does that by the recursively building parent nodes. for uniformity, i chose to add padding node to the tree (with empty hash string). this way the nodes are always even number all the way to the root node. this means unneeded nodes but easier logic. I didn&rsquo;t put much thought about the upper limit for the number of dummy nodes.</p>
<p><code>_buildTree</code> will be called <code>log2(N)</code> where N is number of original leafs. and each call loops over <code>log2(n)</code>
this means <code>log2(N/2) + Log2(N/4) + log2(N/8) ... + log(1)</code> loops.</p>
<p>for each two nodes, hash is calculated with concatenating left and right hashes in that order.</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>    <span style="color:#ff7b72">def</span> <span style="color:#d2a8ff;font-weight:bold">buildTree</span>(self, data):
</span></span><span style="display:flex;"><span>        nodes <span style="color:#ff7b72;font-weight:bold">=</span> [MerkleNode(self<span style="color:#ff7b72;font-weight:bold">.</span>getHash(d)) <span style="color:#ff7b72">for</span> d <span style="color:#ff7b72;font-weight:bold">in</span> data]
</span></span><span style="display:flex;"><span>        self<span style="color:#ff7b72;font-weight:bold">.</span>root <span style="color:#ff7b72;font-weight:bold">=</span> self<span style="color:#ff7b72;font-weight:bold">.</span>_buildTree(nodes,<span style="color:#a5d6ff">1</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#ff7b72">def</span> <span style="color:#d2a8ff;font-weight:bold">_buildTree</span>(self, nodes,level):
</span></span><span style="display:flex;"><span>        <span style="color:#ff7b72">if</span> len(nodes) <span style="color:#ff7b72;font-weight:bold">==</span> <span style="color:#a5d6ff">1</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#ff7b72">return</span> nodes[<span style="color:#a5d6ff">0</span>]
</span></span><span style="display:flex;"><span>        <span style="color:#ff7b72">else</span>:
</span></span><span style="display:flex;"><span>            new_level <span style="color:#ff7b72;font-weight:bold">=</span>[]
</span></span><span style="display:flex;"><span>            <span style="color:#8b949e;font-style:italic"># the extra padding node here!</span>
</span></span><span style="display:flex;"><span>            (depth, isOdd) <span style="color:#ff7b72;font-weight:bold">=</span> divmod(len(nodes),<span style="color:#a5d6ff">2</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#ff7b72">if</span> (isOdd):
</span></span><span style="display:flex;"><span>                nodes<span style="color:#ff7b72;font-weight:bold">.</span>append(MerkleNode(<span style="color:#a5d6ff">&#39;&#39;</span>))
</span></span><span style="display:flex;"><span>                depth <span style="color:#ff7b72;font-weight:bold">=</span> depth <span style="color:#ff7b72;font-weight:bold">+</span> <span style="color:#a5d6ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#ff7b72">for</span> i <span style="color:#ff7b72;font-weight:bold">in</span> range(depth):
</span></span><span style="display:flex;"><span>                left <span style="color:#ff7b72;font-weight:bold">=</span> nodes[<span style="color:#a5d6ff">2</span><span style="color:#ff7b72;font-weight:bold">*</span>i]
</span></span><span style="display:flex;"><span>                right <span style="color:#ff7b72;font-weight:bold">=</span> nodes[<span style="color:#a5d6ff">2</span><span style="color:#ff7b72;font-weight:bold">*</span>i<span style="color:#ff7b72;font-weight:bold">+</span><span style="color:#a5d6ff">1</span>]
</span></span><span style="display:flex;"><span>                children_data <span style="color:#ff7b72;font-weight:bold">=</span> (left<span style="color:#ff7b72;font-weight:bold">.</span>data  <span style="color:#ff7b72;font-weight:bold">+</span> right<span style="color:#ff7b72;font-weight:bold">.</span>data)
</span></span><span style="display:flex;"><span>                node <span style="color:#ff7b72;font-weight:bold">=</span> MerkleNode(self<span style="color:#ff7b72;font-weight:bold">.</span>getHash(children_data)) 
</span></span><span style="display:flex;"><span>                node<span style="color:#ff7b72;font-weight:bold">.</span>left <span style="color:#ff7b72;font-weight:bold">=</span> left
</span></span><span style="display:flex;"><span>                node<span style="color:#ff7b72;font-weight:bold">.</span>right <span style="color:#ff7b72;font-weight:bold">=</span> right
</span></span><span style="display:flex;"><span>                left<span style="color:#ff7b72;font-weight:bold">.</span>parent <span style="color:#ff7b72;font-weight:bold">=</span> node
</span></span><span style="display:flex;"><span>                right<span style="color:#ff7b72;font-weight:bold">.</span>parent <span style="color:#ff7b72;font-weight:bold">=</span> node
</span></span><span style="display:flex;"><span>                new_level<span style="color:#ff7b72;font-weight:bold">.</span>append(node)
</span></span><span style="display:flex;"><span>            <span style="color:#ff7b72">return</span> self<span style="color:#ff7b72;font-weight:bold">.</span>_buildTree(new_level,level <span style="color:#ff7b72;font-weight:bold">+</span><span style="color:#a5d6ff">1</span>)
</span></span></code></pre></div><h1 id="getting-trail">
  Getting Trail
  <a class="heading-link" href="#getting-trail">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h1>
<p>The second part of Merkle tree, is that multiple parties can calculate <em>trail</em> hashes to leaf nodes and we can verify that trail with leaf hash.</p>
<p>for easy implementation,i did the trail traversal in two steps</p>
<ul>
<li>Get the path from root to leaf (if it&rsquo;s there)</li>
<li>if found, iterate on the path and get the sibling child of each node.</li>
</ul>
<p>if hash is not found, <code>getTrail</code> returns <code>[]</code>. if found it returns the path as <code>list</code> of <code>[root, (node,direction), (node,direction)...]</code></p>
<p>There are several improvements that can be done here:</p>
<ul>
<li>change the interface for <code>_getTrail</code> and make it pure instead of using <code>self.found_trail</code></li>
<li>Traverse the tree once and terminate afterwards</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span> <span style="color:#ff7b72">def</span> <span style="color:#d2a8ff;font-weight:bold">getTrail</span>(self,data):
</span></span><span style="display:flex;"><span>        self<span style="color:#ff7b72;font-weight:bold">.</span>trail <span style="color:#ff7b72;font-weight:bold">=</span> []
</span></span><span style="display:flex;"><span>        self<span style="color:#ff7b72;font-weight:bold">.</span>found_trail <span style="color:#ff7b72;font-weight:bold">=</span> []
</span></span><span style="display:flex;"><span>        self<span style="color:#ff7b72;font-weight:bold">.</span>_getTrail(self<span style="color:#ff7b72;font-weight:bold">.</span>root,<span style="color:#a5d6ff">0</span>,data)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#8b949e;font-style:italic"># Trail not found at self.found_trail</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff7b72">if</span> len(self<span style="color:#ff7b72;font-weight:bold">.</span>found_trail) <span style="color:#ff7b72;font-weight:bold">==</span><span style="color:#a5d6ff">0</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#ff7b72">return</span> list()
</span></span><span style="display:flex;"><span>        <span style="color:#8b949e;font-style:italic"># Trail found. from parent(root), get the sibilings</span>
</span></span><span style="display:flex;"><span>        hash_trail <span style="color:#ff7b72;font-weight:bold">=</span> [self<span style="color:#ff7b72;font-weight:bold">.</span>root]
</span></span><span style="display:flex;"><span>        <span style="color:#ff7b72">for</span> idx <span style="color:#ff7b72;font-weight:bold">in</span> range(len(self<span style="color:#ff7b72;font-weight:bold">.</span>found_trail)<span style="color:#ff7b72;font-weight:bold">-</span><span style="color:#a5d6ff">1</span>):
</span></span><span style="display:flex;"><span>            <span style="color:#ff7b72">if</span> (self<span style="color:#ff7b72;font-weight:bold">.</span>found_trail[idx]<span style="color:#ff7b72;font-weight:bold">.</span>left<span style="color:#ff7b72;font-weight:bold">.</span>data <span style="color:#ff7b72;font-weight:bold">==</span> self<span style="color:#ff7b72;font-weight:bold">.</span>found_trail[idx<span style="color:#ff7b72;font-weight:bold">+</span><span style="color:#a5d6ff">1</span>]<span style="color:#ff7b72;font-weight:bold">.</span>data):
</span></span><span style="display:flex;"><span>                hash_trail<span style="color:#ff7b72;font-weight:bold">.</span>append((self<span style="color:#ff7b72;font-weight:bold">.</span>found_trail[idx]<span style="color:#ff7b72;font-weight:bold">.</span>right,<span style="color:#a5d6ff">&#39;left&#39;</span>))
</span></span><span style="display:flex;"><span>            <span style="color:#ff7b72">elif</span> (self<span style="color:#ff7b72;font-weight:bold">.</span>found_trail[idx]<span style="color:#ff7b72;font-weight:bold">.</span>right<span style="color:#ff7b72;font-weight:bold">.</span>data <span style="color:#ff7b72;font-weight:bold">==</span> self<span style="color:#ff7b72;font-weight:bold">.</span>found_trail[idx<span style="color:#ff7b72;font-weight:bold">+</span><span style="color:#a5d6ff">1</span>]<span style="color:#ff7b72;font-weight:bold">.</span>data):
</span></span><span style="display:flex;"><span>                hash_trail<span style="color:#ff7b72;font-weight:bold">.</span>append((self<span style="color:#ff7b72;font-weight:bold">.</span>found_trail[idx]<span style="color:#ff7b72;font-weight:bold">.</span>left,<span style="color:#a5d6ff">&#39;right&#39;</span>))
</span></span><span style="display:flex;"><span>        <span style="color:#ff7b72">return</span> hash_trail
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>    <span style="color:#ff7b72">def</span> <span style="color:#d2a8ff;font-weight:bold">_getTrail</span>(self,node, level,data):
</span></span><span style="display:flex;"><span>        self<span style="color:#ff7b72;font-weight:bold">.</span>trail<span style="color:#ff7b72;font-weight:bold">.</span>append(node)
</span></span><span style="display:flex;"><span>        <span style="color:#ff7b72">if</span>(node<span style="color:#ff7b72;font-weight:bold">.</span>left <span style="color:#ff7b72;font-weight:bold">==</span><span style="color:#79c0ff">None</span> <span style="color:#ff7b72;font-weight:bold">and</span> node<span style="color:#ff7b72;font-weight:bold">.</span>right <span style="color:#ff7b72;font-weight:bold">==</span> <span style="color:#79c0ff">None</span> <span style="color:#ff7b72;font-weight:bold">and</span> data <span style="color:#ff7b72;font-weight:bold">==</span> node<span style="color:#ff7b72;font-weight:bold">.</span>data):
</span></span><span style="display:flex;"><span>            self<span style="color:#ff7b72;font-weight:bold">.</span>found_trail <span style="color:#ff7b72;font-weight:bold">=</span> list(self<span style="color:#ff7b72;font-weight:bold">.</span>trail)
</span></span><span style="display:flex;"><span>        <span style="color:#ff7b72">if</span> node<span style="color:#ff7b72;font-weight:bold">.</span>left <span style="color:#ff7b72;font-weight:bold">!=</span> <span style="color:#79c0ff">None</span>:
</span></span><span style="display:flex;"><span>            self<span style="color:#ff7b72;font-weight:bold">.</span>_getTrail(node<span style="color:#ff7b72;font-weight:bold">.</span>left, level<span style="color:#ff7b72;font-weight:bold">+</span><span style="color:#a5d6ff">1</span>,data)
</span></span><span style="display:flex;"><span>        <span style="color:#ff7b72">if</span> node<span style="color:#ff7b72;font-weight:bold">.</span>right <span style="color:#ff7b72;font-weight:bold">!=</span> <span style="color:#79c0ff">None</span>:
</span></span><span style="display:flex;"><span>            self<span style="color:#ff7b72;font-weight:bold">.</span>_getTrail(node<span style="color:#ff7b72;font-weight:bold">.</span>right,level<span style="color:#ff7b72;font-weight:bold">+</span><span style="color:#a5d6ff">1</span>,data)
</span></span><span style="display:flex;"><span>        self<span style="color:#ff7b72;font-weight:bold">.</span>trail<span style="color:#ff7b72;font-weight:bold">.</span>pop()
</span></span></code></pre></div><h1 id="verify-trail-and-hash">
  Verify trail and hash
  <a class="heading-link" href="#verify-trail-and-hash">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h1>
<p>once we have a trail, we can reverse the trail and calculate the hashes every two nodes all the way up to the root.
I am assuming the trail is given with first node as root then tuples of <code>(node, direction)</code> same as calculated with <code>getTrail</code></p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>    <span style="color:#ff7b72">def</span> <span style="color:#d2a8ff;font-weight:bold">verifyTrail</span>(self,trail, data):
</span></span><span style="display:flex;"><span>        hash <span style="color:#ff7b72;font-weight:bold">=</span> <span style="color:#79c0ff">None</span>
</span></span><span style="display:flex;"><span>        root <span style="color:#ff7b72;font-weight:bold">=</span> trail[<span style="color:#a5d6ff">0</span>]
</span></span><span style="display:flex;"><span>        hash <span style="color:#ff7b72;font-weight:bold">=</span> data
</span></span><span style="display:flex;"><span>        new_trail <span style="color:#ff7b72;font-weight:bold">=</span> list(trail[<span style="color:#a5d6ff">1</span>:])
</span></span><span style="display:flex;"><span>        new_trail<span style="color:#ff7b72;font-weight:bold">.</span>reverse()
</span></span><span style="display:flex;"><span>        <span style="color:#ff7b72">for</span> (node,direction) <span style="color:#ff7b72;font-weight:bold">in</span> new_trail:
</span></span><span style="display:flex;"><span>            <span style="color:#ff7b72">if</span> direction <span style="color:#ff7b72;font-weight:bold">==</span> <span style="color:#a5d6ff">&#39;left&#39;</span>:
</span></span><span style="display:flex;"><span>                term <span style="color:#ff7b72;font-weight:bold">=</span>  hash <span style="color:#ff7b72;font-weight:bold">+</span> node<span style="color:#ff7b72;font-weight:bold">.</span>data
</span></span><span style="display:flex;"><span>            <span style="color:#ff7b72">else</span>:
</span></span><span style="display:flex;"><span>                term <span style="color:#ff7b72;font-weight:bold">=</span> node<span style="color:#ff7b72;font-weight:bold">.</span>data <span style="color:#ff7b72;font-weight:bold">+</span> hash
</span></span><span style="display:flex;"><span>            hash <span style="color:#ff7b72;font-weight:bold">=</span> self<span style="color:#ff7b72;font-weight:bold">.</span>getHash(term)
</span></span><span style="display:flex;"><span>        <span style="color:#ff7b72">return</span> hash <span style="color:#ff7b72;font-weight:bold">==</span> root<span style="color:#ff7b72;font-weight:bold">.</span>data
</span></span></code></pre></div><h1 id="all-together">
  All together
  <a class="heading-link" href="#all-together">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h1>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff7b72">import</span> <span style="color:#ff7b72">hashlib</span>
</span></span><span style="display:flex;"><span><span style="color:#ff7b72">import</span> <span style="color:#ff7b72">string</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff7b72">class</span> <span style="color:#f0883e;font-weight:bold">MerkleNode</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#ff7b72">def</span> __init__(self, data):
</span></span><span style="display:flex;"><span>        self<span style="color:#ff7b72;font-weight:bold">.</span>right <span style="color:#ff7b72;font-weight:bold">=</span> <span style="color:#79c0ff">None</span>
</span></span><span style="display:flex;"><span>        self<span style="color:#ff7b72;font-weight:bold">.</span>left  <span style="color:#ff7b72;font-weight:bold">=</span> <span style="color:#79c0ff">None</span>
</span></span><span style="display:flex;"><span>        self<span style="color:#ff7b72;font-weight:bold">.</span>parent <span style="color:#ff7b72;font-weight:bold">=</span> <span style="color:#79c0ff">None</span>
</span></span><span style="display:flex;"><span>        self<span style="color:#ff7b72;font-weight:bold">.</span>data  <span style="color:#ff7b72;font-weight:bold">=</span> data
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff7b72">class</span> <span style="color:#f0883e;font-weight:bold">MerkleTree</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#ff7b72">def</span> __init__(self):
</span></span><span style="display:flex;"><span>        self<span style="color:#ff7b72;font-weight:bold">.</span>root <span style="color:#ff7b72;font-weight:bold">=</span> <span style="color:#79c0ff">None</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#ff7b72">def</span> <span style="color:#d2a8ff;font-weight:bold">getHash</span>(self,data):
</span></span><span style="display:flex;"><span>        <span style="color:#ff7b72">return</span> hashlib<span style="color:#ff7b72;font-weight:bold">.</span>sha256(data<span style="color:#ff7b72;font-weight:bold">.</span>encode())<span style="color:#ff7b72;font-weight:bold">.</span>hexdigest()
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>    <span style="color:#ff7b72">def</span> <span style="color:#d2a8ff;font-weight:bold">buildTree</span>(self, data):
</span></span><span style="display:flex;"><span>        nodes <span style="color:#ff7b72;font-weight:bold">=</span> [MerkleNode(self<span style="color:#ff7b72;font-weight:bold">.</span>getHash(d)) <span style="color:#ff7b72">for</span> d <span style="color:#ff7b72;font-weight:bold">in</span> data]
</span></span><span style="display:flex;"><span>        self<span style="color:#ff7b72;font-weight:bold">.</span>root <span style="color:#ff7b72;font-weight:bold">=</span> self<span style="color:#ff7b72;font-weight:bold">.</span>_buildTree(nodes,<span style="color:#a5d6ff">1</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#ff7b72">def</span> <span style="color:#d2a8ff;font-weight:bold">_buildTree</span>(self, nodes,level):
</span></span><span style="display:flex;"><span>        <span style="color:#ff7b72">if</span> len(nodes) <span style="color:#ff7b72;font-weight:bold">==</span> <span style="color:#a5d6ff">1</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#ff7b72">return</span> nodes[<span style="color:#a5d6ff">0</span>]
</span></span><span style="display:flex;"><span>        <span style="color:#ff7b72">else</span>:
</span></span><span style="display:flex;"><span>            new_level <span style="color:#ff7b72;font-weight:bold">=</span>[]
</span></span><span style="display:flex;"><span>            (depth, isOdd) <span style="color:#ff7b72;font-weight:bold">=</span> divmod(len(nodes),<span style="color:#a5d6ff">2</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#ff7b72">if</span> (isOdd):
</span></span><span style="display:flex;"><span>                nodes<span style="color:#ff7b72;font-weight:bold">.</span>append(MerkleNode(<span style="color:#a5d6ff">&#39;&#39;</span>))
</span></span><span style="display:flex;"><span>                depth <span style="color:#ff7b72;font-weight:bold">=</span> depth <span style="color:#ff7b72;font-weight:bold">+</span> <span style="color:#a5d6ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#ff7b72">for</span> i <span style="color:#ff7b72;font-weight:bold">in</span> range(depth):
</span></span><span style="display:flex;"><span>                left <span style="color:#ff7b72;font-weight:bold">=</span> nodes[<span style="color:#a5d6ff">2</span><span style="color:#ff7b72;font-weight:bold">*</span>i]
</span></span><span style="display:flex;"><span>                right <span style="color:#ff7b72;font-weight:bold">=</span> nodes[<span style="color:#a5d6ff">2</span><span style="color:#ff7b72;font-weight:bold">*</span>i<span style="color:#ff7b72;font-weight:bold">+</span><span style="color:#a5d6ff">1</span>]
</span></span><span style="display:flex;"><span>                children_data <span style="color:#ff7b72;font-weight:bold">=</span> (left<span style="color:#ff7b72;font-weight:bold">.</span>data  <span style="color:#ff7b72;font-weight:bold">+</span> right<span style="color:#ff7b72;font-weight:bold">.</span>data)
</span></span><span style="display:flex;"><span>                node <span style="color:#ff7b72;font-weight:bold">=</span> MerkleNode(self<span style="color:#ff7b72;font-weight:bold">.</span>getHash(children_data)) 
</span></span><span style="display:flex;"><span>                node<span style="color:#ff7b72;font-weight:bold">.</span>left <span style="color:#ff7b72;font-weight:bold">=</span> left
</span></span><span style="display:flex;"><span>                node<span style="color:#ff7b72;font-weight:bold">.</span>right <span style="color:#ff7b72;font-weight:bold">=</span> right
</span></span><span style="display:flex;"><span>                left<span style="color:#ff7b72;font-weight:bold">.</span>parent <span style="color:#ff7b72;font-weight:bold">=</span> node
</span></span><span style="display:flex;"><span>                right<span style="color:#ff7b72;font-weight:bold">.</span>parent <span style="color:#ff7b72;font-weight:bold">=</span> node
</span></span><span style="display:flex;"><span>                new_level<span style="color:#ff7b72;font-weight:bold">.</span>append(node)
</span></span><span style="display:flex;"><span>            <span style="color:#ff7b72">return</span> self<span style="color:#ff7b72;font-weight:bold">.</span>_buildTree(new_level,level <span style="color:#ff7b72;font-weight:bold">+</span><span style="color:#a5d6ff">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff7b72">def</span> <span style="color:#d2a8ff;font-weight:bold">printTree</span>(self):
</span></span><span style="display:flex;"><span>        self<span style="color:#ff7b72;font-weight:bold">.</span>_printTree(self<span style="color:#ff7b72;font-weight:bold">.</span>root,<span style="color:#a5d6ff">0</span>)
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>    <span style="color:#ff7b72">def</span> <span style="color:#d2a8ff;font-weight:bold">_printTree</span>(self,node, level):
</span></span><span style="display:flex;"><span>        print(<span style="color:#79c0ff">f</span><span style="color:#a5d6ff">&#34;</span><span style="color:#a5d6ff">{</span>level<span style="color:#a5d6ff">}</span><span style="color:#a5d6ff">: </span><span style="color:#a5d6ff">{</span>node<span style="color:#ff7b72;font-weight:bold">.</span>data<span style="color:#a5d6ff">}</span><span style="color:#a5d6ff">&#34;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#ff7b72">if</span> node<span style="color:#ff7b72;font-weight:bold">.</span>left <span style="color:#ff7b72;font-weight:bold">!=</span> <span style="color:#79c0ff">None</span>:
</span></span><span style="display:flex;"><span>            self<span style="color:#ff7b72;font-weight:bold">.</span>_printTree(node<span style="color:#ff7b72;font-weight:bold">.</span>left, level<span style="color:#ff7b72;font-weight:bold">+</span><span style="color:#a5d6ff">1</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#ff7b72">if</span> node<span style="color:#ff7b72;font-weight:bold">.</span>right <span style="color:#ff7b72;font-weight:bold">!=</span> <span style="color:#79c0ff">None</span>:
</span></span><span style="display:flex;"><span>            self<span style="color:#ff7b72;font-weight:bold">.</span>_printTree(node<span style="color:#ff7b72;font-weight:bold">.</span>right,level<span style="color:#ff7b72;font-weight:bold">+</span><span style="color:#a5d6ff">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff7b72">def</span> <span style="color:#d2a8ff;font-weight:bold">getRoot</span>(self):
</span></span><span style="display:flex;"><span>        <span style="color:#ff7b72">return</span> self<span style="color:#ff7b72;font-weight:bold">.</span>root<span style="color:#ff7b72;font-weight:bold">.</span>data
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff7b72">def</span> <span style="color:#d2a8ff;font-weight:bold">getTrail</span>(self,data):
</span></span><span style="display:flex;"><span>        self<span style="color:#ff7b72;font-weight:bold">.</span>trail <span style="color:#ff7b72;font-weight:bold">=</span> []
</span></span><span style="display:flex;"><span>        self<span style="color:#ff7b72;font-weight:bold">.</span>found_trail <span style="color:#ff7b72;font-weight:bold">=</span> []
</span></span><span style="display:flex;"><span>        self<span style="color:#ff7b72;font-weight:bold">.</span>_getTrail(self<span style="color:#ff7b72;font-weight:bold">.</span>root,<span style="color:#a5d6ff">0</span>,data)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#8b949e;font-style:italic"># Trail not found at self.found_trail</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff7b72">if</span> len(self<span style="color:#ff7b72;font-weight:bold">.</span>found_trail) <span style="color:#ff7b72;font-weight:bold">==</span><span style="color:#a5d6ff">0</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#ff7b72">return</span> list()
</span></span><span style="display:flex;"><span>        <span style="color:#8b949e;font-style:italic"># Trail found. from parent(root), get the sibilings</span>
</span></span><span style="display:flex;"><span>        hash_trail <span style="color:#ff7b72;font-weight:bold">=</span> [self<span style="color:#ff7b72;font-weight:bold">.</span>root]
</span></span><span style="display:flex;"><span>        <span style="color:#ff7b72">for</span> idx <span style="color:#ff7b72;font-weight:bold">in</span> range(len(self<span style="color:#ff7b72;font-weight:bold">.</span>found_trail)<span style="color:#ff7b72;font-weight:bold">-</span><span style="color:#a5d6ff">1</span>):
</span></span><span style="display:flex;"><span>            <span style="color:#ff7b72">if</span> (self<span style="color:#ff7b72;font-weight:bold">.</span>found_trail[idx]<span style="color:#ff7b72;font-weight:bold">.</span>left<span style="color:#ff7b72;font-weight:bold">.</span>data <span style="color:#ff7b72;font-weight:bold">==</span> self<span style="color:#ff7b72;font-weight:bold">.</span>found_trail[idx<span style="color:#ff7b72;font-weight:bold">+</span><span style="color:#a5d6ff">1</span>]<span style="color:#ff7b72;font-weight:bold">.</span>data):
</span></span><span style="display:flex;"><span>                hash_trail<span style="color:#ff7b72;font-weight:bold">.</span>append((self<span style="color:#ff7b72;font-weight:bold">.</span>found_trail[idx]<span style="color:#ff7b72;font-weight:bold">.</span>right,<span style="color:#a5d6ff">&#39;left&#39;</span>))
</span></span><span style="display:flex;"><span>            <span style="color:#ff7b72">elif</span> (self<span style="color:#ff7b72;font-weight:bold">.</span>found_trail[idx]<span style="color:#ff7b72;font-weight:bold">.</span>right<span style="color:#ff7b72;font-weight:bold">.</span>data <span style="color:#ff7b72;font-weight:bold">==</span> self<span style="color:#ff7b72;font-weight:bold">.</span>found_trail[idx<span style="color:#ff7b72;font-weight:bold">+</span><span style="color:#a5d6ff">1</span>]<span style="color:#ff7b72;font-weight:bold">.</span>data):
</span></span><span style="display:flex;"><span>                hash_trail<span style="color:#ff7b72;font-weight:bold">.</span>append((self<span style="color:#ff7b72;font-weight:bold">.</span>found_trail[idx]<span style="color:#ff7b72;font-weight:bold">.</span>left,<span style="color:#a5d6ff">&#39;right&#39;</span>))
</span></span><span style="display:flex;"><span>        <span style="color:#ff7b72">return</span> hash_trail
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>    <span style="color:#ff7b72">def</span> <span style="color:#d2a8ff;font-weight:bold">_getTrail</span>(self,node, level,data):
</span></span><span style="display:flex;"><span>        self<span style="color:#ff7b72;font-weight:bold">.</span>trail<span style="color:#ff7b72;font-weight:bold">.</span>append(node)
</span></span><span style="display:flex;"><span>        <span style="color:#ff7b72">if</span>(node<span style="color:#ff7b72;font-weight:bold">.</span>left <span style="color:#ff7b72;font-weight:bold">==</span><span style="color:#79c0ff">None</span> <span style="color:#ff7b72;font-weight:bold">and</span> node<span style="color:#ff7b72;font-weight:bold">.</span>right <span style="color:#ff7b72;font-weight:bold">==</span> <span style="color:#79c0ff">None</span> <span style="color:#ff7b72;font-weight:bold">and</span> data <span style="color:#ff7b72;font-weight:bold">==</span> node<span style="color:#ff7b72;font-weight:bold">.</span>data):
</span></span><span style="display:flex;"><span>            self<span style="color:#ff7b72;font-weight:bold">.</span>found_trail <span style="color:#ff7b72;font-weight:bold">=</span> list(self<span style="color:#ff7b72;font-weight:bold">.</span>trail)
</span></span><span style="display:flex;"><span>        <span style="color:#ff7b72">if</span> node<span style="color:#ff7b72;font-weight:bold">.</span>left <span style="color:#ff7b72;font-weight:bold">!=</span> <span style="color:#79c0ff">None</span>:
</span></span><span style="display:flex;"><span>            self<span style="color:#ff7b72;font-weight:bold">.</span>_getTrail(node<span style="color:#ff7b72;font-weight:bold">.</span>left, level<span style="color:#ff7b72;font-weight:bold">+</span><span style="color:#a5d6ff">1</span>,data)
</span></span><span style="display:flex;"><span>        <span style="color:#ff7b72">if</span> node<span style="color:#ff7b72;font-weight:bold">.</span>right <span style="color:#ff7b72;font-weight:bold">!=</span> <span style="color:#79c0ff">None</span>:
</span></span><span style="display:flex;"><span>            self<span style="color:#ff7b72;font-weight:bold">.</span>_getTrail(node<span style="color:#ff7b72;font-weight:bold">.</span>right,level<span style="color:#ff7b72;font-weight:bold">+</span><span style="color:#a5d6ff">1</span>,data)
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        self<span style="color:#ff7b72;font-weight:bold">.</span>trail<span style="color:#ff7b72;font-weight:bold">.</span>pop()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff7b72">def</span> <span style="color:#d2a8ff;font-weight:bold">verifyTrail</span>(self,trail, data):
</span></span><span style="display:flex;"><span>        hash <span style="color:#ff7b72;font-weight:bold">=</span> <span style="color:#79c0ff">None</span>
</span></span><span style="display:flex;"><span>        root <span style="color:#ff7b72;font-weight:bold">=</span> trail[<span style="color:#a5d6ff">0</span>]
</span></span><span style="display:flex;"><span>        hash <span style="color:#ff7b72;font-weight:bold">=</span> data
</span></span><span style="display:flex;"><span>        new_trail <span style="color:#ff7b72;font-weight:bold">=</span> list(trail[<span style="color:#a5d6ff">1</span>:])
</span></span><span style="display:flex;"><span>        new_trail<span style="color:#ff7b72;font-weight:bold">.</span>reverse()
</span></span><span style="display:flex;"><span>        <span style="color:#ff7b72">for</span> (node,direction) <span style="color:#ff7b72;font-weight:bold">in</span> new_trail:
</span></span><span style="display:flex;"><span>            <span style="color:#ff7b72">if</span> direction <span style="color:#ff7b72;font-weight:bold">==</span> <span style="color:#a5d6ff">&#39;left&#39;</span>:
</span></span><span style="display:flex;"><span>                term <span style="color:#ff7b72;font-weight:bold">=</span>  hash <span style="color:#ff7b72;font-weight:bold">+</span> node<span style="color:#ff7b72;font-weight:bold">.</span>data
</span></span><span style="display:flex;"><span>            <span style="color:#ff7b72">else</span>:
</span></span><span style="display:flex;"><span>                term <span style="color:#ff7b72;font-weight:bold">=</span> node<span style="color:#ff7b72;font-weight:bold">.</span>data <span style="color:#ff7b72;font-weight:bold">+</span> hash
</span></span><span style="display:flex;"><span>            hash <span style="color:#ff7b72;font-weight:bold">=</span> self<span style="color:#ff7b72;font-weight:bold">.</span>getHash(term)
</span></span><span style="display:flex;"><span>        <span style="color:#ff7b72">return</span> hash <span style="color:#ff7b72;font-weight:bold">==</span> root<span style="color:#ff7b72;font-weight:bold">.</span>data
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff7b72">def</span> <span style="color:#d2a8ff;font-weight:bold">main</span>():
</span></span><span style="display:flex;"><span>    file <span style="color:#ff7b72;font-weight:bold">=</span> <span style="color:#a5d6ff">&#34;01234567&#34;</span> 
</span></span><span style="display:flex;"><span>    data <span style="color:#ff7b72;font-weight:bold">=</span> list(file)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    tree <span style="color:#ff7b72;font-weight:bold">=</span> MerkleTree()
</span></span><span style="display:flex;"><span>    tree<span style="color:#ff7b72;font-weight:bold">.</span>buildTree(data)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    print(<span style="color:#79c0ff">f</span><span style="color:#a5d6ff">&#34;Root: </span><span style="color:#a5d6ff">{</span>tree<span style="color:#ff7b72;font-weight:bold">.</span>getRoot()<span style="color:#a5d6ff">}</span><span style="color:#a5d6ff">&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    tree<span style="color:#ff7b72;font-weight:bold">.</span>printTree()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    trail <span style="color:#ff7b72;font-weight:bold">=</span> tree<span style="color:#ff7b72;font-weight:bold">.</span>getTrail(tree<span style="color:#ff7b72;font-weight:bold">.</span>getHash(<span style="color:#a5d6ff">&#34;3&#34;</span>))
</span></span><span style="display:flex;"><span>    ret <span style="color:#ff7b72;font-weight:bold">=</span> tree<span style="color:#ff7b72;font-weight:bold">.</span>verifyTrail(trail,tree<span style="color:#ff7b72;font-weight:bold">.</span>getHash(<span style="color:#a5d6ff">&#34;3&#34;</span>))
</span></span><span style="display:flex;"><span>    print(<span style="color:#79c0ff">f</span><span style="color:#a5d6ff">&#34;</span><span style="color:#a5d6ff">{</span>ret<span style="color:#a5d6ff">}</span><span style="color:#a5d6ff">&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff7b72">if</span> __name__ <span style="color:#ff7b72;font-weight:bold">==</span> <span style="color:#a5d6ff">&#34;__main__&#34;</span>:
</span></span><span style="display:flex;"><span>    main()
</span></span></code></pre></div>
      </div>


      <footer>
        


        
        
        
        
        
        
        
      </footer>
    </article>

    
  </section>

    </div>

    <footer class="footer">
  <section class="container">
    ©
    
    2025
    
    ·
    
      Licensed under <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA-4.0</a>
    ·
    
    Powered by <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> & <a href="https://github.com/luizdepra/hugo-coder/" target="_blank" rel="noopener">Coder</a>.
    
  </section>
</footer>

  </main>

  

  
  
  <script src="/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js" integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script>
  

  

  


  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  
</body>

</html>
