<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="author" content="">
<meta name="description" content="Maze path finding is an interesting problem to find if there path(and the path) between start and dest points on grid. More details on wiki. There many solutions some of them are more complicate than others. I am looking at backtracking or A* search. Normally simple solution is model the grid (open cells) as graph nodes and try to find shorted path between two nodes.
In this instance of this problem, there is an extra requirement." />
<meta name="keywords" content=", python, algorithms" />
<meta name="robots" content="noodp" />
<meta name="theme-color" content="" />
<link rel="canonical" href="/posts/2022/05/simple-recursive-solution-to-maze-path-finding/" />


    <title>
        
            Simple recursive solution to Maze path finding :: Techiedeepdive 
        
    </title>



<link href="https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.5.0/css/flag-icon.min.css" rel="stylesheet"
    type="text/css">



<link rel="stylesheet" href="/main.de188b3201233c251f4fd6306dbd2cb41e408fb8846c09781b2925de7df5025c.css">






<meta itemprop="name" content="Simple recursive solution to Maze path finding">
<meta itemprop="description" content="Maze path finding is an interesting problem to find if there path(and the path) between start and dest points on grid. More details on wiki. There many solutions some of them are more complicate than others. I am looking at backtracking or A* search. Normally simple solution is model the grid (open cells) as graph nodes and try to find shorted path between two nodes.
In this instance of this problem, there is an extra requirement."><meta itemprop="datePublished" content="2022-05-23T00:00:00+00:00" />
<meta itemprop="dateModified" content="2022-05-23T00:00:00+00:00" />
<meta itemprop="wordCount" content="349"><meta itemprop="image" content=""/>
<meta itemprop="keywords" content="python,algorithms," />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content=""/>

<meta name="twitter:title" content="Simple recursive solution to Maze path finding"/>
<meta name="twitter:description" content="Maze path finding is an interesting problem to find if there path(and the path) between start and dest points on grid. More details on wiki. There many solutions some of them are more complicate than others. I am looking at backtracking or A* search. Normally simple solution is model the grid (open cells) as graph nodes and try to find shorted path between two nodes.
In this instance of this problem, there is an extra requirement."/>




    <meta property="og:title" content="Simple recursive solution to Maze path finding" />
<meta property="og:description" content="Maze path finding is an interesting problem to find if there path(and the path) between start and dest points on grid. More details on wiki. There many solutions some of them are more complicate than others. I am looking at backtracking or A* search. Normally simple solution is model the grid (open cells) as graph nodes and try to find shorted path between two nodes.
In this instance of this problem, there is an extra requirement." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/2022/05/simple-recursive-solution-to-maze-path-finding/" /><meta property="og:image" content=""/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-23T00:00:00+00:00" />
<meta property="article:modified_time" content="2022-05-23T00:00:00+00:00" /><meta property="og:site_name" content="Techiedeepdive" />







    <meta property="article:published_time" content="2022-05-23 00:00:00 &#43;0000 UTC" />








    </head>

    
        <body>
    
    
        <div class="container">
            <header class="header">
    <span class="header__inner">
        <a href="/" style="text-decoration: none;">
    <div class="logo">
        
            <span class="logo__mark">></span>
            <span class="logo__text">$ cd /home/</span>
            <span class="logo__cursor" style=
                  "
                   
                   ">
            </span>
        
    </div>
</a>


        <span class="header__right">
            
                <nav class="menu">
    <ul class="menu__inner"><li><a href="/about/">About</a></li><li><a href="/posts">Blog</a></li><li><a href="/reading-list/">Reading list</a></li><li><a href="/tags/">Tags</a></li>
    </ul>
</nav>

                <span class="menu-trigger">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                        <path d="M0 0h24v24H0z" fill="none"/>
                        <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
                    </svg>
                </span>
            
        </span>
    </span>
</header>


            <div class="content">
                
  <main class="post">

    <div class="post-info">
      <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock">
          <circle cx="12" cy="12" r="10"></circle>
          <polyline points="12 6 12 12 16 14"></polyline>
        </svg>
        2 minutes

        
      </p>
    </div>

    <article>
      <h1 class="post-title">
        <a href="/posts/2022/05/simple-recursive-solution-to-maze-path-finding/">Simple recursive solution to Maze path finding</a>
      </h1>

      

      

      <div class="post-content">
        <p>Maze path finding  is an interesting problem to find if there path(and the path) between start and dest points on grid. More details on <a href="https://en.wikipedia.org/wiki/Maze-solving_algorithm">wiki</a>. There many solutions some of them are more complicate than others. I am looking at backtracking or A* search. Normally simple solution is model the grid (open cells) as graph nodes and try to find shorted path between two nodes.</p>
<p>In this instance of this problem, there is an extra requirement. At each cell, you can only move into one of neighbours cells (left, right, up and down). so, recursion looks like a good solution here.</p>
<p>Starting from Point(or cell) class with some utility methods.</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#fff;font-weight:bold">class</span> Point:
    <span style="color:#fff;font-weight:bold">def</span> __init__(self, x=<span style="color:#ff0;font-weight:bold">0</span>, y=<span style="color:#ff0;font-weight:bold">0</span>):
        self.x = x
        self.y = y

    <span style="color:#fff;font-weight:bold">def</span> randomize(self,N):
        self.x = random.randrange(<span style="color:#ff0;font-weight:bold">0</span>, N)
        self.y = random.randrange(<span style="color:#ff0;font-weight:bold">0</span>, N)

    <span style="color:#fff;font-weight:bold">def</span> __iter__(self):
        <span style="color:#fff;font-weight:bold">yield</span> self.x
        <span style="color:#fff;font-weight:bold">yield</span> self.y

    <span style="color:#fff;font-weight:bold">def</span> __str__(self):
            <span style="color:#fff;font-weight:bold">return</span> <span style="color:#0ff;font-weight:bold">&#34;(</span><span style="color:#0ff;font-weight:bold">{0}</span><span style="color:#0ff;font-weight:bold">,</span><span style="color:#0ff;font-weight:bold">{1}</span><span style="color:#0ff;font-weight:bold">)&#34;</span>.format(self.x,self.y)

    <span style="color:#fff;font-weight:bold">def</span> __eq__(self, other):
        <span style="color:#fff;font-weight:bold">if</span> (self.x == other.x and self.y == other.y):
            <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">True</span>
        <span style="color:#fff;font-weight:bold">else</span>:
            <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">False</span>
</code></pre></div><p>Another utility methos is <code>get_adj</code> which calculates the agj neighbours of given cell</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">        <span style="color:#fff;font-weight:bold">def</span> get_adj(point):
            adj = []
            <span style="color:#fff;font-weight:bold">for</span> idx in [-<span style="color:#ff0;font-weight:bold">1</span>, <span style="color:#ff0;font-weight:bold">1</span>]:
                <span style="color:#fff;font-weight:bold">if</span> (point.x + idx &lt; self.N and point.x + idx &gt;=<span style="color:#ff0;font-weight:bold">0</span> ):
                    p = Point(point.x + idx, point.y)
                    adj.append(p)

                <span style="color:#fff;font-weight:bold">if</span> (point.y + idx &lt; self.N and point.y +idx &gt;=<span style="color:#ff0;font-weight:bold">0</span> ):
                    p = Point(point.x , point.y + idx)
                    adj.append(p)
            <span style="color:#fff;font-weight:bold">return</span> adj
</code></pre></div><p>Finally, The recursive function <code>move</code> iterates over open neighbours cells. The recursion breaks if dest is found or neighbours are iterated. Well, Something i had to do is limit recursion to neighbours except the one i already come from otherwise, it can get stuck between two points.</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">    <span style="color:#fff;font-weight:bold">def</span> run(self):


        <span style="color:#fff;font-weight:bold">def</span> move(point, prev, dest):

            <span style="color:#fff;font-weight:bold">print</span>(<span style="color:#0ff;font-weight:bold">f</span><span style="color:#0ff;font-weight:bold">&#34;move called with </span><span style="color:#0ff;font-weight:bold">{</span>point<span style="color:#0ff;font-weight:bold">}</span><span style="color:#0ff;font-weight:bold">&#34;</span>)
            <span style="color:#fff;font-weight:bold">if</span> point == dest:
                <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">True</span>

            adj = get_adj(point)

            <span style="color:#fff;font-weight:bold">for</span> p in adj:
                <span style="color:#fff;font-weight:bold">if</span> self.grid[<span style="color:#fff;font-weight:bold">tuple</span>(p)] and (not (p==prev)):
                    res =  move(p, point, dest)
                    <span style="color:#fff;font-weight:bold">print</span>(<span style="color:#0ff;font-weight:bold">f</span><span style="color:#0ff;font-weight:bold">&#34;Results:</span><span style="color:#0ff;font-weight:bold">{</span>res<span style="color:#0ff;font-weight:bold">}</span><span style="color:#0ff;font-weight:bold"> point:</span><span style="color:#0ff;font-weight:bold">{</span>point<span style="color:#0ff;font-weight:bold">}</span><span style="color:#0ff;font-weight:bold"> adj:</span><span style="color:#0ff;font-weight:bold">{</span>p<span style="color:#0ff;font-weight:bold">}</span><span style="color:#0ff;font-weight:bold"> prev:</span><span style="color:#0ff;font-weight:bold">{</span>prev<span style="color:#0ff;font-weight:bold">}</span><span style="color:#0ff;font-weight:bold">&#34;</span>)
                    <span style="color:#fff;font-weight:bold">if</span> res:
                        <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">True</span>

            <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">False</span>
</code></pre></div><p>Finally, this is not really path between start and dest. <code>move</code> can return True if there is a path between and start and dest.
that said, the recursion can print the path while unrolling the recursive call. Maybe in another evening!</p>

      </div>
    </article>

    <hr />

    <div class="post-info">
      
    <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line></svg>

        <span class="tag"><a href="tags/python/">python</a></span>
        <span class="tag"><a href="tags/algorithms/">algorithms</a></span>
        
    </p>

      

      <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text">
          <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
          <polyline points="14 2 14 8 20 8"></polyline>
          <line x1="16" y1="13" x2="8" y2="13"></line>
          <line x1="16" y1="17" x2="8" y2="17"></line>
          <polyline points="10 9 9 9 8 9"></polyline>
        </svg>
        349 Words
      </p>

      <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar">
          <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
          <line x1="16" y1="2" x2="16" y2="6"></line>
          <line x1="8" y1="2" x2="8" y2="6"></line>
          <line x1="3" y1="10" x2="21" y2="10"></line>
        </svg>
        
          2022-05-23 01:00 &#43;0100
        

         
          
        
      </p>
    </div>

    
      <div class="pagination">
        <div class="pagination__title">
          <span class="pagination__title-h">Read other posts</span>
          <hr />
        </div>

        <div class="pagination__buttons">
          
            <span class="button previous">
              <a href="/posts/2022/05/levenshtein-distance/">
                <span class="button__icon">←</span>
                <span class="button__text">Levenshtein Distance</span>
              </a>
            </span>
          

          
            <span class="button next">
              <a href="/posts/2022/05/waveforms-and-wavejson-wavedrom-and-wavedrompy/">
                <span class="button__text">Waveforms and WaveJSON - wavedrom and wavedrompy</span>
                <span class="button__icon">→</span>
              </a>
            </span>
          
        </div>
      </div>
    


    

    

  </main>

            </div>

            
                <footer class="footer">
    <div class="footer__inner">
        <div class="footer__content">
            <span>&copy; 2023</span>
            
            <span><a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0</a></span><span><a href="posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a></span>
        </div>
    </div>
    <div class="footer__inner">
        <div class="footer__content">
            <span>Powered by <a href="http://gohugo.io">Hugo</a></span>
            <span>Made with &#10084; by <a href="https://github.com/rhazdon">Djordje Atlialp</a></span>
          </div>
    </div>
</footer>

            
        </div>

        



<script type="text/javascript" src="/bundle.min.2ce64ea6ea44a72b13dd812fc2eb5cca3efe878cce258a47c137c17edf46e0602a05e422b618a5b80b5939c731b7a293351c2f2222a21f6ee27e54a8448dd20e.js" integrity="sha512-LOZOpupEpysT3YEvwutcyj7&#43;h4zOJYpHwTfBft9G4GAqBeQithiluAtZOccxt6KTNRwvIiKiH27iflSoRI3SDg=="></script>



    </body>
</html>
