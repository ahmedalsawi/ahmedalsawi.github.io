<!DOCTYPE html>
<html lang="en">

<head>
  <title>
  Simple recursive solution to Maze path finding · Techiedeepdive
</title>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="color-scheme" content="light dark">




<meta name="description" content="Maze path finding  is an interesting problem to find if there path(and the path) between start and dest points on grid. More details on wiki. There many solutions some of them are more complicate than others. I am looking at backtracking or A* search. Normally simple solution is model the grid (open cells) as graph nodes and try to find shorted path between two nodes.
In this instance of this problem, there is an extra requirement. At each cell, you can only move into one of neighbours cells (left, right, up and down). so, recursion looks like a good solution here.">
<meta name="keywords" content="homepage, blog">



  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:image" content="/">
  <meta name="twitter:title" content="Simple recursive solution to Maze path finding">
  <meta name="twitter:description" content="Maze path finding is an interesting problem to find if there path(and the path) between start and dest points on grid. More details on wiki. There many solutions some of them are more complicate than others. I am looking at backtracking or A* search. Normally simple solution is model the grid (open cells) as graph nodes and try to find shorted path between two nodes.
In this instance of this problem, there is an extra requirement. At each cell, you can only move into one of neighbours cells (left, right, up and down). so, recursion looks like a good solution here.">

<meta property="og:url" content="/posts/2022/05/simple-recursive-solution-to-maze-path-finding/">
  <meta property="og:site_name" content="Techiedeepdive">
  <meta property="og:title" content="Simple recursive solution to Maze path finding">
  <meta property="og:description" content="Maze path finding is an interesting problem to find if there path(and the path) between start and dest points on grid. More details on wiki. There many solutions some of them are more complicate than others. I am looking at backtracking or A* search. Normally simple solution is model the grid (open cells) as graph nodes and try to find shorted path between two nodes.
In this instance of this problem, there is an extra requirement. At each cell, you can only move into one of neighbours cells (left, right, up and down). so, recursion looks like a good solution here.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2022-05-23T00:00:00+00:00">
    <meta property="article:modified_time" content="2022-05-23T00:00:00+00:00">
    <meta property="article:tag" content="Python">
    <meta property="article:tag" content="Algorithms">
    <meta property="og:image" content="/">




<link rel="canonical" href="/posts/2022/05/simple-recursive-solution-to-maze-path-finding/">


<link rel="preload" href="/fonts/fa-brands-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="/fonts/fa-regular-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="/fonts/fa-solid-900.woff2" as="font" type="font/woff2" crossorigin>


  
  
  <link rel="stylesheet" href="/css/coder.min.aa5ef26fa979d6793724ae2dbd71efa94fd16cb1c5c7db3b6651f21f9892a5fd.css" integrity="sha256-ql7yb6l51nk3JK4tvXHvqU/RbLHFx9s7ZlHyH5iSpf0=" crossorigin="anonymous" media="screen" />






  
    
    
    <link rel="stylesheet" href="/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css" integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin="anonymous" media="screen" />
  



 




<link rel="icon" type="image/svg+xml" href="/images/favicon.svg" sizes="any">
<link rel="icon" type="image/png" href="/images/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/images/favicon-16x16.png" sizes="16x16">

<link rel="apple-touch-icon" href="/images/apple-touch-icon.png">
<link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">









</head>






<body class="preload-transitions colorscheme-auto">
  
<div class="float-container">
    <a id="dark-mode-toggle" class="colorscheme-toggle">
        <i class="fa-solid fa-adjust fa-fw" aria-hidden="true"></i>
    </a>
</div>


  <main class="wrapper">
    <nav class="navigation">
  <section class="container">
    
    <a class="navigation-title" href="/">
      Techiedeepdive
    </a>
    
    
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa-solid fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link " href="/posts">Blog</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/reading-list/">Reading list</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/tags/">Tags</a>
            </li>
          
        
        
      </ul>
    
  </section>
</nav>


    <div class="content">
      
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">
            <a class="title-link" href="/posts/2022/05/simple-recursive-solution-to-maze-path-finding/">
              Simple recursive solution to Maze path finding
            </a>
          </h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fa-solid fa-calendar" aria-hidden="true"></i>
              <time datetime="2022-05-23T00:00:00Z">
                May 23, 2022
              </time>
            </span>
            <span class="reading-time">
              <i class="fa-solid fa-clock" aria-hidden="true"></i>
              2-minute read
            </span>
          </div>
          
          
          <div class="tags">
  <i class="fa-solid fa-tag" aria-hidden="true"></i>
    <span class="tag">
      <a href="/tags/python/">Python</a>
    </span>
      <span class="separator">•</span>
    <span class="tag">
      <a href="/tags/algorithms/">Algorithms</a>
    </span></div>

        </div>
      </header>

      <div class="post-content">
        
        <p>Maze path finding  is an interesting problem to find if there path(and the path) between start and dest points on grid. More details on <a href="https://en.wikipedia.org/wiki/Maze-solving_algorithm"  class="external-link" target="_blank" rel="noopener">wiki</a>. There many solutions some of them are more complicate than others. I am looking at backtracking or A* search. Normally simple solution is model the grid (open cells) as graph nodes and try to find shorted path between two nodes.</p>
<p>In this instance of this problem, there is an extra requirement. At each cell, you can only move into one of neighbours cells (left, right, up and down). so, recursion looks like a good solution here.</p>
<p>Starting from Point(or cell) class with some utility methods.</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#ff7b72">class</span> <span style="color:#f0883e;font-weight:bold">Point</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#ff7b72">def</span> <span style="color:#d2a8ff;font-weight:bold">__init__</span>(self, x<span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#a5d6ff">0</span>, y<span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#a5d6ff">0</span>):
</span></span><span style="display:flex;"><span>        self<span style="color:#ff7b72;font-weight:bold">.</span>x <span style="color:#ff7b72;font-weight:bold">=</span> x
</span></span><span style="display:flex;"><span>        self<span style="color:#ff7b72;font-weight:bold">.</span>y <span style="color:#ff7b72;font-weight:bold">=</span> y
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff7b72">def</span> <span style="color:#d2a8ff;font-weight:bold">randomize</span>(self,N):
</span></span><span style="display:flex;"><span>        self<span style="color:#ff7b72;font-weight:bold">.</span>x <span style="color:#ff7b72;font-weight:bold">=</span> random<span style="color:#ff7b72;font-weight:bold">.</span>randrange(<span style="color:#a5d6ff">0</span>, N)
</span></span><span style="display:flex;"><span>        self<span style="color:#ff7b72;font-weight:bold">.</span>y <span style="color:#ff7b72;font-weight:bold">=</span> random<span style="color:#ff7b72;font-weight:bold">.</span>randrange(<span style="color:#a5d6ff">0</span>, N)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff7b72">def</span> <span style="color:#d2a8ff;font-weight:bold">__iter__</span>(self):
</span></span><span style="display:flex;"><span>        <span style="color:#ff7b72">yield</span> self<span style="color:#ff7b72;font-weight:bold">.</span>x
</span></span><span style="display:flex;"><span>        <span style="color:#ff7b72">yield</span> self<span style="color:#ff7b72;font-weight:bold">.</span>y
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff7b72">def</span> <span style="color:#d2a8ff;font-weight:bold">__str__</span>(self):
</span></span><span style="display:flex;"><span>            <span style="color:#ff7b72">return</span> <span style="color:#a5d6ff">&#34;(</span><span style="color:#a5d6ff">{0}</span><span style="color:#a5d6ff">,</span><span style="color:#a5d6ff">{1}</span><span style="color:#a5d6ff">)&#34;</span><span style="color:#ff7b72;font-weight:bold">.</span>format(self<span style="color:#ff7b72;font-weight:bold">.</span>x,self<span style="color:#ff7b72;font-weight:bold">.</span>y)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff7b72">def</span> <span style="color:#d2a8ff;font-weight:bold">__eq__</span>(self, other):
</span></span><span style="display:flex;"><span>        <span style="color:#ff7b72">if</span> (self<span style="color:#ff7b72;font-weight:bold">.</span>x <span style="color:#ff7b72;font-weight:bold">==</span> other<span style="color:#ff7b72;font-weight:bold">.</span>x <span style="color:#ff7b72;font-weight:bold">and</span> self<span style="color:#ff7b72;font-weight:bold">.</span>y <span style="color:#ff7b72;font-weight:bold">==</span> other<span style="color:#ff7b72;font-weight:bold">.</span>y):
</span></span><span style="display:flex;"><span>            <span style="color:#ff7b72">return</span> <span style="color:#79c0ff">True</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff7b72">else</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#ff7b72">return</span> <span style="color:#79c0ff">False</span>
</span></span></code></pre></div><p>Another utility methos is <code>get_adj</code> which calculates the agj neighbours of given cell</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>        <span style="color:#ff7b72">def</span> <span style="color:#d2a8ff;font-weight:bold">get_adj</span>(point):
</span></span><span style="display:flex;"><span>            adj <span style="color:#ff7b72;font-weight:bold">=</span> []
</span></span><span style="display:flex;"><span>            <span style="color:#ff7b72">for</span> idx <span style="color:#ff7b72;font-weight:bold">in</span> [<span style="color:#ff7b72;font-weight:bold">-</span><span style="color:#a5d6ff">1</span>, <span style="color:#a5d6ff">1</span>]:
</span></span><span style="display:flex;"><span>                <span style="color:#ff7b72">if</span> (point<span style="color:#ff7b72;font-weight:bold">.</span>x <span style="color:#ff7b72;font-weight:bold">+</span> idx <span style="color:#ff7b72;font-weight:bold">&lt;</span> self<span style="color:#ff7b72;font-weight:bold">.</span>N <span style="color:#ff7b72;font-weight:bold">and</span> point<span style="color:#ff7b72;font-weight:bold">.</span>x <span style="color:#ff7b72;font-weight:bold">+</span> idx <span style="color:#ff7b72;font-weight:bold">&gt;=</span><span style="color:#a5d6ff">0</span> ):
</span></span><span style="display:flex;"><span>                    p <span style="color:#ff7b72;font-weight:bold">=</span> Point(point<span style="color:#ff7b72;font-weight:bold">.</span>x <span style="color:#ff7b72;font-weight:bold">+</span> idx, point<span style="color:#ff7b72;font-weight:bold">.</span>y)
</span></span><span style="display:flex;"><span>                    adj<span style="color:#ff7b72;font-weight:bold">.</span>append(p)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#ff7b72">if</span> (point<span style="color:#ff7b72;font-weight:bold">.</span>y <span style="color:#ff7b72;font-weight:bold">+</span> idx <span style="color:#ff7b72;font-weight:bold">&lt;</span> self<span style="color:#ff7b72;font-weight:bold">.</span>N <span style="color:#ff7b72;font-weight:bold">and</span> point<span style="color:#ff7b72;font-weight:bold">.</span>y <span style="color:#ff7b72;font-weight:bold">+</span>idx <span style="color:#ff7b72;font-weight:bold">&gt;=</span><span style="color:#a5d6ff">0</span> ):
</span></span><span style="display:flex;"><span>                    p <span style="color:#ff7b72;font-weight:bold">=</span> Point(point<span style="color:#ff7b72;font-weight:bold">.</span>x , point<span style="color:#ff7b72;font-weight:bold">.</span>y <span style="color:#ff7b72;font-weight:bold">+</span> idx)
</span></span><span style="display:flex;"><span>                    adj<span style="color:#ff7b72;font-weight:bold">.</span>append(p)
</span></span><span style="display:flex;"><span>            <span style="color:#ff7b72">return</span> adj
</span></span></code></pre></div><p>Finally, The recursive function <code>move</code> iterates over open neighbours cells. The recursion breaks if dest is found or neighbours are iterated. Well, Something i had to do is limit recursion to neighbours except the one i already come from otherwise, it can get stuck between two points.</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>    <span style="color:#ff7b72">def</span> <span style="color:#d2a8ff;font-weight:bold">run</span>(self):
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff7b72">def</span> <span style="color:#d2a8ff;font-weight:bold">move</span>(point, prev, dest):
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            print(<span style="color:#79c0ff">f</span><span style="color:#a5d6ff">&#34;move called with </span><span style="color:#a5d6ff">{</span>point<span style="color:#a5d6ff">}</span><span style="color:#a5d6ff">&#34;</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#ff7b72">if</span> point <span style="color:#ff7b72;font-weight:bold">==</span> dest:
</span></span><span style="display:flex;"><span>                <span style="color:#ff7b72">return</span> <span style="color:#79c0ff">True</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            adj <span style="color:#ff7b72;font-weight:bold">=</span> get_adj(point)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#ff7b72">for</span> p <span style="color:#ff7b72;font-weight:bold">in</span> adj:
</span></span><span style="display:flex;"><span>                <span style="color:#ff7b72">if</span> self<span style="color:#ff7b72;font-weight:bold">.</span>grid[tuple(p)] <span style="color:#ff7b72;font-weight:bold">and</span> (<span style="color:#ff7b72;font-weight:bold">not</span> (p<span style="color:#ff7b72;font-weight:bold">==</span>prev)):
</span></span><span style="display:flex;"><span>                    res <span style="color:#ff7b72;font-weight:bold">=</span>  move(p, point, dest)
</span></span><span style="display:flex;"><span>                    print(<span style="color:#79c0ff">f</span><span style="color:#a5d6ff">&#34;Results:</span><span style="color:#a5d6ff">{</span>res<span style="color:#a5d6ff">}</span><span style="color:#a5d6ff"> point:</span><span style="color:#a5d6ff">{</span>point<span style="color:#a5d6ff">}</span><span style="color:#a5d6ff"> adj:</span><span style="color:#a5d6ff">{</span>p<span style="color:#a5d6ff">}</span><span style="color:#a5d6ff"> prev:</span><span style="color:#a5d6ff">{</span>prev<span style="color:#a5d6ff">}</span><span style="color:#a5d6ff">&#34;</span>)
</span></span><span style="display:flex;"><span>                    <span style="color:#ff7b72">if</span> res:
</span></span><span style="display:flex;"><span>                        <span style="color:#ff7b72">return</span> <span style="color:#79c0ff">True</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#ff7b72">return</span> <span style="color:#79c0ff">False</span>
</span></span></code></pre></div><p>Finally, this is not really path between start and dest. <code>move</code> can return True if there is a path between and start and dest.
that said, the recursion can print the path while unrolling the recursive call. Maybe in another evening!</p>

      </div>


      <footer>
        


        
        
        
        
        
        
        
      </footer>
    </article>

    
  </section>

    </div>

    <footer class="footer">
  <section class="container">
    ©
    
    2025
    
    ·
    
      Licensed under <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA-4.0</a>
    ·
    
    Powered by <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> & <a href="https://github.com/luizdepra/hugo-coder/" target="_blank" rel="noopener">Coder</a>.
    
  </section>
</footer>

  </main>

  

  
  
  <script src="/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js" integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script>
  

  

  


  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  
</body>

</html>
