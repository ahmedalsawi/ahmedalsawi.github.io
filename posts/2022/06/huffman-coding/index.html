<!DOCTYPE html>
<html lang="en">

<head>
  <title>
  Huffman Coding · Techiedeepdive
</title>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="color-scheme" content="light dark">




<meta name="description" content="Huffman code is one of the lossless compression algos. The idea is using a coding where more frequent symbols have shorter encoding and less frequent symbols with longer encoding(variable length encoding). A variant of Huffman is used for JPEG standard, so apparently it&rsquo;s a big deal.
The simple algorithm on wiki is described as follows:
 Create a leaf node for each symbol and add it to the priority queue. While there is more than one node in the queue: Remove the two nodes of highest priority (lowest probability) from the queue Create a new internal node with these two nodes as children and with probability equal to the sum of the two nodes&#39; probabilities.">
<meta name="keywords" content="">

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content=""/>

<meta name="twitter:title" content="Huffman Coding"/>
<meta name="twitter:description" content="Huffman code is one of the lossless compression algos. The idea is using a coding where more frequent symbols have shorter encoding and less frequent symbols with longer encoding(variable length encoding). A variant of Huffman is used for JPEG standard, so apparently it&rsquo;s a big deal.
The simple algorithm on wiki is described as follows:
 Create a leaf node for each symbol and add it to the priority queue. While there is more than one node in the queue: Remove the two nodes of highest priority (lowest probability) from the queue Create a new internal node with these two nodes as children and with probability equal to the sum of the two nodes&#39; probabilities."/>

<meta property="og:title" content="Huffman Coding" />
<meta property="og:description" content="Huffman code is one of the lossless compression algos. The idea is using a coding where more frequent symbols have shorter encoding and less frequent symbols with longer encoding(variable length encoding). A variant of Huffman is used for JPEG standard, so apparently it&rsquo;s a big deal.
The simple algorithm on wiki is described as follows:
 Create a leaf node for each symbol and add it to the priority queue. While there is more than one node in the queue: Remove the two nodes of highest priority (lowest probability) from the queue Create a new internal node with these two nodes as children and with probability equal to the sum of the two nodes&#39; probabilities." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/2022/06/huffman-coding/" /><meta property="og:image" content=""/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-14T00:00:00+00:00" />
<meta property="article:modified_time" content="2022-06-14T00:00:00+00:00" /><meta property="og:site_name" content="Techiedeepdive" />





<link rel="canonical" href="/posts/2022/06/huffman-coding/">


<link rel="preload" href="/fonts/fa-brands-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="/fonts/fa-regular-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="/fonts/fa-solid-900.woff2" as="font" type="font/woff2" crossorigin>


  
  
  <link rel="stylesheet" href="/css/coder.min.577e3c5ead537873430da16f0964b754a120fd87c4e2203a00686e7c75b51378.css" integrity="sha256-V348Xq1TeHNDDaFvCWS3VKEg/YfE4iA6AGhufHW1E3g=" crossorigin="anonymous" media="screen" />






  
    
    
    <link rel="stylesheet" href="/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css" integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin="anonymous" media="screen" />
  



 




<link rel="icon" type="image/svg+xml" href="/images/favicon.svg" sizes="any">
<link rel="icon" type="image/png" href="/images/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/images/favicon-16x16.png" sizes="16x16">

<link rel="apple-touch-icon" href="/images/apple-touch-icon.png">
<link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">









</head>






<body class="preload-transitions colorscheme-auto">
  
<div class="float-container">
    <a id="dark-mode-toggle" class="colorscheme-toggle">
        <i class="fa-solid fa-adjust fa-fw" aria-hidden="true"></i>
    </a>
</div>


  <main class="wrapper">
    <nav class="navigation">
  <section class="container">
    
    <a class="navigation-title" href="">
      Techiedeepdive
    </a>
    
    
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa-solid fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link " href="/posts">Blog</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/reading-list/">Reading list</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/tags/">Tags</a>
            </li>
          
        
        
      </ul>
    
  </section>
</nav>


    <div class="content">
      
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">
            <a class="title-link" href="/posts/2022/06/huffman-coding/">
              Huffman Coding
            </a>
          </h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fa-solid fa-calendar" aria-hidden="true"></i>
              <time datetime="2022-06-14T00:00:00Z">
                June 14, 2022
              </time>
            </span>
            <span class="reading-time">
              <i class="fa-solid fa-clock" aria-hidden="true"></i>
              2-minute read
            </span>
          </div>
          
          
          <div class="tags">
  <i class="fa-solid fa-tag" aria-hidden="true"></i>
    <span class="tag">
      <a href="/tags/info-theory/">info-theory</a>
    </span></div>

        </div>
      </header>

      <div class="post-content">
        
        <p><a href="https://en.wikipedia.org/wiki/Huffman_coding"  class="external-link" target="_blank" rel="noopener">Huffman code</a> is one of the lossless compression algos. The idea is using a coding where more frequent symbols have shorter encoding and less frequent symbols with longer encoding(variable length encoding).  A variant of Huffman is used for JPEG standard, so apparently it&rsquo;s a big deal.</p>
<p>The simple algorithm on wiki is described as follows:</p>
<blockquote>
<p>Create a leaf node for each symbol and add it to the priority queue.
While there is more than one node in the queue:
Remove the two nodes of highest priority (lowest probability) from the queue
Create a new internal node with these two nodes as children and with probability equal to the sum of the two nodes' probabilities.
Add the new node to the queue.
The remaining node is the root node and the tree is complete.</p>
</blockquote>
<h1 id="the-algorithm">
  The algorithm
  <a class="heading-link" href="#the-algorithm">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h1>
<p>First, we need to get the frequency of symbols. This is quick and (very) dirty way.</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">TEXT = <span style="color:#0ff;font-weight:bold">&#34;A_DEAD_DAD_CEDED_A_BAD_BABE_A_BEADED_ABACA_BED&#34;</span>

<span style="color:#fff;font-weight:bold">def</span> calc_symbols_freq(txt):
    symbols = []

    txt = <span style="color:#fff;font-weight:bold">sorted</span>(<span style="color:#fff;font-weight:bold">list</span>(txt))

    start = <span style="color:#ff0;font-weight:bold">0</span>
    end = <span style="color:#ff0;font-weight:bold">0</span>
    i = <span style="color:#ff0;font-weight:bold">0</span>
    txt += [<span style="color:#0ff;font-weight:bold">&#39;$&#39;</span>]
    <span style="color:#fff;font-weight:bold">while</span> (i &lt; <span style="color:#fff;font-weight:bold">len</span>(txt)):
        <span style="color:#fff;font-weight:bold">if</span> i == <span style="color:#fff;font-weight:bold">len</span>(txt) - <span style="color:#ff0;font-weight:bold">1</span>:
            <span style="color:#fff;font-weight:bold">break</span>
        <span style="color:#fff;font-weight:bold">if</span> txt[i] != txt[i+<span style="color:#ff0;font-weight:bold">1</span>]:
            end = i
            symbols.append((txt[i], end-start+<span style="color:#ff0;font-weight:bold">1</span>))
            start = end + <span style="color:#ff0;font-weight:bold">1</span>
        i += <span style="color:#ff0;font-weight:bold">1</span>
    <span style="color:#fff;font-weight:bold">return</span> symbols
</code></pre></div><p>The algorithm mentions using priority queue to keep the queue sorted. Well, Life is too short. So, I used a normal list and kept sorting it (I am probably wanted by the performance police by now)</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#fff;font-weight:bold">class</span> Node:
    <span style="color:#fff;font-weight:bold">def</span> __init__(self, sym, w, left=<span style="color:#fff;font-weight:bold">None</span>, right=<span style="color:#fff;font-weight:bold">None</span>, parent=<span style="color:#fff;font-weight:bold">None</span>):
        self.sym    = sym
        self.w      = w
        self.parent = parent
        self.left   = left
        self.right  = right
    <span style="color:#fff;font-weight:bold">def</span> __str__(self):
        <span style="color:#fff;font-weight:bold">return</span> <span style="color:#0ff;font-weight:bold">f</span><span style="color:#0ff;font-weight:bold">&#34;</span><span style="color:#0ff;font-weight:bold">{</span>self.sym<span style="color:#0ff;font-weight:bold">}</span><span style="color:#0ff;font-weight:bold">: </span><span style="color:#0ff;font-weight:bold">{</span>self.w<span style="color:#0ff;font-weight:bold">}</span><span style="color:#0ff;font-weight:bold">&#34;</span>

<span style="color:#fff;font-weight:bold">class</span> Tree():

    <span style="color:#fff;font-weight:bold">def</span> __init__(self, syms):
        self.root = <span style="color:#fff;font-weight:bold">None</span>
        q = []

        <span style="color:#fff;font-weight:bold">for</span> sym in syms:
            q.append(Node(sym[<span style="color:#ff0;font-weight:bold">0</span>], sym[<span style="color:#ff0;font-weight:bold">1</span>]))

        q = <span style="color:#fff;font-weight:bold">sorted</span>(q, key=<span style="color:#fff;font-weight:bold">lambda</span> x: x.w, reverse=<span style="color:#fff;font-weight:bold">True</span>)

        <span style="color:#fff;font-weight:bold">while</span> ( <span style="color:#fff;font-weight:bold">len</span>(q) &gt; <span style="color:#ff0;font-weight:bold">1</span>):
            a = q.pop()
            b = q.pop()

            node = Node(a.sym + b.sym , a.w + b.w, a, b)
            a.parent = node
            b.parent = node

            q.append(node)
            q = <span style="color:#fff;font-weight:bold">sorted</span>(q, key=<span style="color:#fff;font-weight:bold">lambda</span> x: x.w, reverse=<span style="color:#fff;font-weight:bold">True</span>)


        <span style="color:#007f7f"># the remaining node is the root</span>
        <span style="color:#fff;font-weight:bold">assert</span>(<span style="color:#fff;font-weight:bold">len</span>(q) == <span style="color:#ff0;font-weight:bold">1</span>)
        self.root = q.pop()

        <span style="color:#007f7f"># traverse all paths to leaf nodes</span>
        <span style="color:#fff;font-weight:bold">def</span> traverse(n, path):
            <span style="color:#fff;font-weight:bold">if</span>(n.left):
                traverse(n.left, path+<span style="color:#0ff;font-weight:bold">&#34;0&#34;</span>)
            <span style="color:#fff;font-weight:bold">else</span>:
                <span style="color:#fff;font-weight:bold">print</span>(n, <span style="color:#0ff;font-weight:bold">&#34; &#34;</span>, path)
            <span style="color:#fff;font-weight:bold">if</span>(n.right):
                traverse(n.right, path+<span style="color:#0ff;font-weight:bold">&#34;1&#34;</span>)

        traverse(self.root, <span style="color:#0ff;font-weight:bold">&#34;&#34;</span>)

    <span style="color:#fff;font-weight:bold">def</span> encode(self, txt):
        <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">None</span>

syms = calc_symbols_freq(TEXT)
tree = Tree(syms)
</code></pre></div><p>And the output matches wiki results. hurrah!</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">_: <span style="color:#ff0;font-weight:bold">10</span>   <span style="color:#ff0;font-weight:bold">00</span>
D: <span style="color:#ff0;font-weight:bold">10</span>   <span style="color:#ff0;font-weight:bold">01</span>
A: <span style="color:#ff0;font-weight:bold">11</span>   <span style="color:#ff0;font-weight:bold">10</span>
E: <span style="color:#ff0;font-weight:bold">7</span>   <span style="color:#ff0;font-weight:bold">110</span>
C: <span style="color:#ff0;font-weight:bold">2</span>   <span style="color:#ff0;font-weight:bold">1110</span>
B: <span style="color:#ff0;font-weight:bold">6</span>   <span style="color:#ff0;font-weight:bold">1111</span>
</code></pre></div>
      </div>


      <footer>
        


        
        
        
        
        

        
      </footer>
    </article>

    
  </section>

    </div>

    <footer class="footer">
  <section class="container">
    ©
    
    2024
    
    ·
    
      Licensed under <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA-4.0</a>
    ·
    
    Powered by <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> & <a href="https://github.com/luizdepra/hugo-coder/" target="_blank" rel="noopener">Coder</a>.
    
  </section>
</footer>

  </main>

  

  
  
  <script src="/js/coder.min.369d90111ae4409b4e51de5efd23a46b92663fcc82dc9a0efde7f70bffc3f949.js" integrity="sha256-Np2QERrkQJtOUd5e/SOka5JmP8yC3JoO/ef3C//D&#43;Uk="></script>
  

  

  


  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  
</body>

</html>
