<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="author" content="">
<meta name="description" content="Huffman code is one of the lossless compression algos. The idea is using a coding where more frequent symbols have shorter encoding and less frequent symbols with longer encoding(variable length encoding). A variant of Huffman is used for JPEG standard, so apparently it&amp;rsquo;s a big deal.
The simple algorithm on wiki is described as follows:
 Create a leaf node for each symbol and add it to the priority queue. While there is more than one node in the queue: Remove the two nodes of highest priority (lowest probability) from the queue Create a new internal node with these two nodes as children and with probability equal to the sum of the two nodes&#39; probabilities." />
<meta name="keywords" content=", info-theory" />
<meta name="robots" content="noodp" />
<meta name="theme-color" content="" />
<link rel="canonical" href="/posts/2022/06/huffman-coding/" />


    <title>
        
            Huffman Coding :: Techiedeepdive 
        
    </title>



<link href="https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.5.0/css/flag-icon.min.css" rel="stylesheet"
    type="text/css">



<link rel="stylesheet" href="/main.de188b3201233c251f4fd6306dbd2cb41e408fb8846c09781b2925de7df5025c.css">






<meta itemprop="name" content="Huffman Coding">
<meta itemprop="description" content="Huffman code is one of the lossless compression algos. The idea is using a coding where more frequent symbols have shorter encoding and less frequent symbols with longer encoding(variable length encoding). A variant of Huffman is used for JPEG standard, so apparently it&rsquo;s a big deal.
The simple algorithm on wiki is described as follows:
 Create a leaf node for each symbol and add it to the priority queue. While there is more than one node in the queue: Remove the two nodes of highest priority (lowest probability) from the queue Create a new internal node with these two nodes as children and with probability equal to the sum of the two nodes&#39; probabilities."><meta itemprop="datePublished" content="2022-06-14T00:00:00+00:00" />
<meta itemprop="dateModified" content="2022-06-14T00:00:00+00:00" />
<meta itemprop="wordCount" content="401"><meta itemprop="image" content=""/>
<meta itemprop="keywords" content="info-theory," />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content=""/>

<meta name="twitter:title" content="Huffman Coding"/>
<meta name="twitter:description" content="Huffman code is one of the lossless compression algos. The idea is using a coding where more frequent symbols have shorter encoding and less frequent symbols with longer encoding(variable length encoding). A variant of Huffman is used for JPEG standard, so apparently it&rsquo;s a big deal.
The simple algorithm on wiki is described as follows:
 Create a leaf node for each symbol and add it to the priority queue. While there is more than one node in the queue: Remove the two nodes of highest priority (lowest probability) from the queue Create a new internal node with these two nodes as children and with probability equal to the sum of the two nodes&#39; probabilities."/>




    <meta property="og:title" content="Huffman Coding" />
<meta property="og:description" content="Huffman code is one of the lossless compression algos. The idea is using a coding where more frequent symbols have shorter encoding and less frequent symbols with longer encoding(variable length encoding). A variant of Huffman is used for JPEG standard, so apparently it&rsquo;s a big deal.
The simple algorithm on wiki is described as follows:
 Create a leaf node for each symbol and add it to the priority queue. While there is more than one node in the queue: Remove the two nodes of highest priority (lowest probability) from the queue Create a new internal node with these two nodes as children and with probability equal to the sum of the two nodes&#39; probabilities." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/2022/06/huffman-coding/" /><meta property="og:image" content=""/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-14T00:00:00+00:00" />
<meta property="article:modified_time" content="2022-06-14T00:00:00+00:00" /><meta property="og:site_name" content="Techiedeepdive" />







    <meta property="article:published_time" content="2022-06-14 00:00:00 &#43;0000 UTC" />








    </head>

    
        <body>
    
    
        <div class="container">
            <header class="header">
    <span class="header__inner">
        <a href="/" style="text-decoration: none;">
    <div class="logo">
        
            <span class="logo__mark">></span>
            <span class="logo__text">$ cd /home/</span>
            <span class="logo__cursor" style=
                  "
                   
                   ">
            </span>
        
    </div>
</a>


        <span class="header__right">
            
                <nav class="menu">
    <ul class="menu__inner"><li><a href="/about/">About</a></li><li><a href="/posts">Blog</a></li><li><a href="/reading-list/">Reading list</a></li><li><a href="/tags/">Tags</a></li>
    </ul>
</nav>

                <span class="menu-trigger">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                        <path d="M0 0h24v24H0z" fill="none"/>
                        <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
                    </svg>
                </span>
            
        </span>
    </span>
</header>


            <div class="content">
                
  <main class="post">

    <div class="post-info">
      <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock">
          <circle cx="12" cy="12" r="10"></circle>
          <polyline points="12 6 12 12 16 14"></polyline>
        </svg>
        2 minutes

        
      </p>
    </div>

    <article>
      <h1 class="post-title">
        <a href="/posts/2022/06/huffman-coding/">Huffman Coding</a>
      </h1>

      

      

      <div class="post-content">
        <p><a href="https://en.wikipedia.org/wiki/Huffman_coding">Huffman code</a> is one of the lossless compression algos. The idea is using a coding where more frequent symbols have shorter encoding and less frequent symbols with longer encoding(variable length encoding).  A variant of Huffman is used for JPEG standard, so apparently it&rsquo;s a big deal.</p>
<p>The simple algorithm on wiki is described as follows:</p>
<blockquote>
<p>Create a leaf node for each symbol and add it to the priority queue.
While there is more than one node in the queue:
Remove the two nodes of highest priority (lowest probability) from the queue
Create a new internal node with these two nodes as children and with probability equal to the sum of the two nodes' probabilities.
Add the new node to the queue.
The remaining node is the root node and the tree is complete.</p>
</blockquote>
<h1 id="the-algorithm">The algorithm</h1>
<p>First, we need to get the frequency of symbols. This is quick and (very) dirty way.</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">TEXT = <span style="color:#0ff;font-weight:bold">&#34;A_DEAD_DAD_CEDED_A_BAD_BABE_A_BEADED_ABACA_BED&#34;</span>

<span style="color:#fff;font-weight:bold">def</span> calc_symbols_freq(txt):
    symbols = []

    txt = <span style="color:#fff;font-weight:bold">sorted</span>(<span style="color:#fff;font-weight:bold">list</span>(txt))

    start = <span style="color:#ff0;font-weight:bold">0</span>
    end = <span style="color:#ff0;font-weight:bold">0</span>
    i = <span style="color:#ff0;font-weight:bold">0</span>
    txt += [<span style="color:#0ff;font-weight:bold">&#39;$&#39;</span>]
    <span style="color:#fff;font-weight:bold">while</span> (i &lt; <span style="color:#fff;font-weight:bold">len</span>(txt)):
        <span style="color:#fff;font-weight:bold">if</span> i == <span style="color:#fff;font-weight:bold">len</span>(txt) - <span style="color:#ff0;font-weight:bold">1</span>:
            <span style="color:#fff;font-weight:bold">break</span>
        <span style="color:#fff;font-weight:bold">if</span> txt[i] != txt[i+<span style="color:#ff0;font-weight:bold">1</span>]:
            end = i
            symbols.append((txt[i], end-start+<span style="color:#ff0;font-weight:bold">1</span>))
            start = end + <span style="color:#ff0;font-weight:bold">1</span>
        i += <span style="color:#ff0;font-weight:bold">1</span>
    <span style="color:#fff;font-weight:bold">return</span> symbols
</code></pre></div><p>The algorithm mentions using priority queue to keep the queue sorted. Well, Life is too short. So, I used a normal list and kept sorting it (I am probably wanted by the performance police by now)</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#fff;font-weight:bold">class</span> Node:
    <span style="color:#fff;font-weight:bold">def</span> __init__(self, sym, w, left=<span style="color:#fff;font-weight:bold">None</span>, right=<span style="color:#fff;font-weight:bold">None</span>, parent=<span style="color:#fff;font-weight:bold">None</span>):
        self.sym    = sym
        self.w      = w
        self.parent = parent
        self.left   = left
        self.right  = right
    <span style="color:#fff;font-weight:bold">def</span> __str__(self):
        <span style="color:#fff;font-weight:bold">return</span> <span style="color:#0ff;font-weight:bold">f</span><span style="color:#0ff;font-weight:bold">&#34;</span><span style="color:#0ff;font-weight:bold">{</span>self.sym<span style="color:#0ff;font-weight:bold">}</span><span style="color:#0ff;font-weight:bold">: </span><span style="color:#0ff;font-weight:bold">{</span>self.w<span style="color:#0ff;font-weight:bold">}</span><span style="color:#0ff;font-weight:bold">&#34;</span>

<span style="color:#fff;font-weight:bold">class</span> Tree():

    <span style="color:#fff;font-weight:bold">def</span> __init__(self, syms):
        self.root = <span style="color:#fff;font-weight:bold">None</span>
        q = []

        <span style="color:#fff;font-weight:bold">for</span> sym in syms:
            q.append(Node(sym[<span style="color:#ff0;font-weight:bold">0</span>], sym[<span style="color:#ff0;font-weight:bold">1</span>]))

        q = <span style="color:#fff;font-weight:bold">sorted</span>(q, key=<span style="color:#fff;font-weight:bold">lambda</span> x: x.w, reverse=<span style="color:#fff;font-weight:bold">True</span>)

        <span style="color:#fff;font-weight:bold">while</span> ( <span style="color:#fff;font-weight:bold">len</span>(q) &gt; <span style="color:#ff0;font-weight:bold">1</span>):
            a = q.pop()
            b = q.pop()

            node = Node(a.sym + b.sym , a.w + b.w, a, b)
            a.parent = node
            b.parent = node

            q.append(node)
            q = <span style="color:#fff;font-weight:bold">sorted</span>(q, key=<span style="color:#fff;font-weight:bold">lambda</span> x: x.w, reverse=<span style="color:#fff;font-weight:bold">True</span>)


        <span style="color:#007f7f"># the remaining node is the root</span>
        <span style="color:#fff;font-weight:bold">assert</span>(<span style="color:#fff;font-weight:bold">len</span>(q) == <span style="color:#ff0;font-weight:bold">1</span>)
        self.root = q.pop()

        <span style="color:#007f7f"># traverse all paths to leaf nodes</span>
        <span style="color:#fff;font-weight:bold">def</span> traverse(n, path):
            <span style="color:#fff;font-weight:bold">if</span>(n.left):
                traverse(n.left, path+<span style="color:#0ff;font-weight:bold">&#34;0&#34;</span>)
            <span style="color:#fff;font-weight:bold">else</span>:
                <span style="color:#fff;font-weight:bold">print</span>(n, <span style="color:#0ff;font-weight:bold">&#34; &#34;</span>, path)
            <span style="color:#fff;font-weight:bold">if</span>(n.right):
                traverse(n.right, path+<span style="color:#0ff;font-weight:bold">&#34;1&#34;</span>)

        traverse(self.root, <span style="color:#0ff;font-weight:bold">&#34;&#34;</span>)

    <span style="color:#fff;font-weight:bold">def</span> encode(self, txt):
        <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">None</span>

syms = calc_symbols_freq(TEXT)
tree = Tree(syms)
</code></pre></div><p>And the output matches wiki results. hurrah!</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">_: <span style="color:#ff0;font-weight:bold">10</span>   <span style="color:#ff0;font-weight:bold">00</span>
D: <span style="color:#ff0;font-weight:bold">10</span>   <span style="color:#ff0;font-weight:bold">01</span>
A: <span style="color:#ff0;font-weight:bold">11</span>   <span style="color:#ff0;font-weight:bold">10</span>
E: <span style="color:#ff0;font-weight:bold">7</span>   <span style="color:#ff0;font-weight:bold">110</span>
C: <span style="color:#ff0;font-weight:bold">2</span>   <span style="color:#ff0;font-weight:bold">1110</span>
B: <span style="color:#ff0;font-weight:bold">6</span>   <span style="color:#ff0;font-weight:bold">1111</span>
</code></pre></div>
      </div>
    </article>

    <hr />

    <div class="post-info">
      
    <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line></svg>

        <span class="tag"><a href="tags/info-theory/">info-theory</a></span>
        
    </p>

      

      <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text">
          <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
          <polyline points="14 2 14 8 20 8"></polyline>
          <line x1="16" y1="13" x2="8" y2="13"></line>
          <line x1="16" y1="17" x2="8" y2="17"></line>
          <polyline points="10 9 9 9 8 9"></polyline>
        </svg>
        401 Words
      </p>

      <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar">
          <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
          <line x1="16" y1="2" x2="16" y2="6"></line>
          <line x1="8" y1="2" x2="8" y2="6"></line>
          <line x1="3" y1="10" x2="21" y2="10"></line>
        </svg>
        
          2022-06-14 01:00 &#43;0100
        

         
          
        
      </p>
    </div>

    
      <div class="pagination">
        <div class="pagination__title">
          <span class="pagination__title-h">Read other posts</span>
          <hr />
        </div>

        <div class="pagination__buttons">
          
            <span class="button previous">
              <a href="/posts/2022/06/discrete-cosine-transform-dct/">
                <span class="button__icon">←</span>
                <span class="button__text">Discrete Cosine Transform - DCT</span>
              </a>
            </span>
          

          
            <span class="button next">
              <a href="/posts/2022/06/solving-n-queen-using-systemverilog-constraints/">
                <span class="button__text">Solving N-Queen using Systemverilog Constraints</span>
                <span class="button__icon">→</span>
              </a>
            </span>
          
        </div>
      </div>
    


    

    

  </main>

            </div>

            
                <footer class="footer">
    <div class="footer__inner">
        <div class="footer__content">
            <span>&copy; 2023</span>
            
            <span><a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0</a></span><span><a href="posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a></span>
        </div>
    </div>
    <div class="footer__inner">
        <div class="footer__content">
            <span>Powered by <a href="http://gohugo.io">Hugo</a></span>
            <span>Made with &#10084; by <a href="https://github.com/rhazdon">Djordje Atlialp</a></span>
          </div>
    </div>
</footer>

            
        </div>

        



<script type="text/javascript" src="/bundle.min.2ce64ea6ea44a72b13dd812fc2eb5cca3efe878cce258a47c137c17edf46e0602a05e422b618a5b80b5939c731b7a293351c2f2222a21f6ee27e54a8448dd20e.js" integrity="sha512-LOZOpupEpysT3YEvwutcyj7&#43;h4zOJYpHwTfBft9G4GAqBeQithiluAtZOccxt6KTNRwvIiKiH27iflSoRI3SDg=="></script>



    </body>
</html>
