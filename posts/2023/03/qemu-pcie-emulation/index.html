<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="author" content="">
<meta name="description" content="This post is about how qemu emulates PCI devices for guest Kernel. Honestly, I took the scenic road here which is reading the code and setting breakpoints in GDB at interesting places and work my way through the stack trace. Disclaimer, This is a very short post on a complicated topic and huge code base(Qemu). But It&amp;rsquo;s a good start to dig deeper into qemu code (more specifically PCI emulation in qemu)" />
<meta name="keywords" content=", qemu" />
<meta name="robots" content="noodp" />
<meta name="theme-color" content="" />
<link rel="canonical" href="/posts/2023/03/qemu-pcie-emulation/" />


    <title>
        
            Qemu PCIe Emulation :: Techiedeepdive 
        
    </title>



<link href="https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.5.0/css/flag-icon.min.css" rel="stylesheet"
    type="text/css">



<link rel="stylesheet" href="/main.de188b3201233c251f4fd6306dbd2cb41e408fb8846c09781b2925de7df5025c.css">






<meta itemprop="name" content="Qemu PCIe Emulation">
<meta itemprop="description" content="This post is about how qemu emulates PCI devices for guest Kernel. Honestly, I took the scenic road here which is reading the code and setting breakpoints in GDB at interesting places and work my way through the stack trace. Disclaimer, This is a very short post on a complicated topic and huge code base(Qemu). But It&rsquo;s a good start to dig deeper into qemu code (more specifically PCI emulation in qemu)"><meta itemprop="datePublished" content="2023-03-19T00:00:00+00:00" />
<meta itemprop="dateModified" content="2023-03-19T00:00:00+00:00" />
<meta itemprop="wordCount" content="1030"><meta itemprop="image" content=""/>
<meta itemprop="keywords" content="qemu," />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content=""/>

<meta name="twitter:title" content="Qemu PCIe Emulation"/>
<meta name="twitter:description" content="This post is about how qemu emulates PCI devices for guest Kernel. Honestly, I took the scenic road here which is reading the code and setting breakpoints in GDB at interesting places and work my way through the stack trace. Disclaimer, This is a very short post on a complicated topic and huge code base(Qemu). But It&rsquo;s a good start to dig deeper into qemu code (more specifically PCI emulation in qemu)"/>




    <meta property="og:title" content="Qemu PCIe Emulation" />
<meta property="og:description" content="This post is about how qemu emulates PCI devices for guest Kernel. Honestly, I took the scenic road here which is reading the code and setting breakpoints in GDB at interesting places and work my way through the stack trace. Disclaimer, This is a very short post on a complicated topic and huge code base(Qemu). But It&rsquo;s a good start to dig deeper into qemu code (more specifically PCI emulation in qemu)" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/2023/03/qemu-pcie-emulation/" /><meta property="og:image" content=""/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-19T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-03-19T00:00:00+00:00" /><meta property="og:site_name" content="Techiedeepdive" />







    <meta property="article:published_time" content="2023-03-19 00:00:00 &#43;0000 UTC" />








    </head>

    
        <body>
    
    
        <div class="container">
            <header class="header">
    <span class="header__inner">
        <a href="/" style="text-decoration: none;">
    <div class="logo">
        
            <span class="logo__mark">></span>
            <span class="logo__text">$ cd /home/</span>
            <span class="logo__cursor" style=
                  "
                   
                   ">
            </span>
        
    </div>
</a>


        <span class="header__right">
            
                <nav class="menu">
    <ul class="menu__inner"><li><a href="/about/">About</a></li><li><a href="/posts">Blog</a></li><li><a href="/reading-list/">Reading list</a></li><li><a href="/tags/">Tags</a></li>
    </ul>
</nav>

                <span class="menu-trigger">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                        <path d="M0 0h24v24H0z" fill="none"/>
                        <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
                    </svg>
                </span>
            
        </span>
    </span>
</header>


            <div class="content">
                
  <main class="post">

    <div class="post-info">
      <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock">
          <circle cx="12" cy="12" r="10"></circle>
          <polyline points="12 6 12 12 16 14"></polyline>
        </svg>
        5 minutes

        
      </p>
    </div>

    <article>
      <h1 class="post-title">
        <a href="/posts/2023/03/qemu-pcie-emulation/">Qemu PCIe Emulation</a>
      </h1>

      

      

      <div class="post-content">
        <p>This post is about how qemu emulates PCI devices for guest Kernel. Honestly, I took the scenic road here which is reading the code and setting breakpoints in GDB at interesting places and work my way through the stack trace. Disclaimer, This is a very short post on a complicated topic and huge code base(Qemu). But It&rsquo;s a good start to dig deeper into qemu code (more specifically PCI emulation in qemu)</p>
<h1 id="compiling-qemu-for-gdbb">Compiling Qemu for gdbb</h1>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">sudo apt install libpixman-1-dev libglib2.0-dev

mkdir build
<span style="color:#fff;font-weight:bold">cd</span> build

../configure --target-list=x86_64-softmmu --enable-debug

</code></pre></div><h1 id="chipset-emulation-initialization">Chipset Emulation Initialization</h1>
<p>Qemu has several chipset support. The oldest one is i440fx in <code>hw/pci-host/i440fx.c</code>, It defines pc_init1 which is the entry point for  emulating that chipset. This is a stack trace starting from  <code>main</code> all the way down ( or up :)) to pc_init1.</p>
<pre tabindex="0"><code>#0  pc_init1 (machine=0x555556c88400, host_type=0x5555561acef9 &quot;i440FX-pcihost&quot;, pci_type=0x5555561acef2 &quot;i440FX&quot;) at ../hw/i386/pc_piix.c:93
#1  0x0000555555bd9563 in pc_init_v8_0 (machine=0x555556c88400) at ../hw/i386/pc_piix.c:464
#2  0x00005555558f0a19 in machine_run_board_init (machine=0x555556c88400, mem_path=0x0, errp=0x5555569bc2e0 &lt;error_fatal&gt;) at ../hw/core/machine.c:1408
#3  0x0000555555b0df44 in qemu_init_board () at ../softmmu/vl.c:2513
#4  0x0000555555b0e1e5 in qmp_x_exit_preconfig (errp=0x5555569bc2e0 &lt;error_fatal&gt;) at ../softmmu/vl.c:2609
#5  0x0000555555b10a97 in qemu_init (argc=10, argv=0x7fffffffdea8) at ../softmmu/vl.c:3612
#6  0x000055555585c6cb in main (argc=10, argv=0x7fffffffdea8) at ../softmmu/main.c:47
</code></pre><p>In the next few snippets, I will trace the stacktrace above. Starting with <code>qmp_x_exit_preconfig</code></p>
<pre tabindex="0"><code>void qmp_x_exit_preconfig(Error **errp)
{
    if (phase_check(PHASE_MACHINE_INITIALIZED)) {
        error_setg(errp, &quot;The command is permitted only before machine initialization&quot;);
        return;
    }

    qemu_init_board();
    qemu_create_cli_devices();
    qemu_machine_creation_done();
</code></pre><p>Which calls <code>qemu_init_board</code></p>
<pre tabindex="0"><code>static void qemu_init_board(void)
{

    /* From here on we enter MACHINE_PHASE_INITIALIZED.  */
    machine_run_board_init(current_machine, mem_path, &amp;error_fatal);
    ....
}
</code></pre><p><code>machine_run_board_init</code> does few things but the most import part here is <code>machine_class-&gt;init(machine);</code></p>
<pre tabindex="0"><code>    accel_init_interfaces(ACCEL_GET_CLASS(machine-&gt;accelerator));
    machine_class-&gt;init(machine);
    phase_advance(PHASE_MACHINE_INITIAL
</code></pre><p>Which eventually calls <code>pc_init</code>. The interesting part in <code>pc_init1</code> is the call to <code>i440fx_init</code></p>
<pre tabindex="0"><code>        pci_bus = i440fx_init(pci_type,
                              i440fx_host,
                              system_memory, system_io, machine-&gt;ram_size,
                              x86ms-&gt;below_4g_mem_size,
                              x86ms-&gt;above_4g_mem_size,
                              pci_memory, ram_memory);
</code></pre><p><code>i440fx_init</code> created root host bridge and populates devices</p>
<pre tabindex="0"><code>PCIBus *i440fx_init(const char *pci_type,
                    DeviceState *dev,
                    MemoryRegion *address_space_mem,
                    MemoryRegion *address_space_io,
                    ram_addr_t ram_size,
                    ram_addr_t below_4g_mem_size,
                    ram_addr_t above_4g_mem_size,
                    MemoryRegion *pci_address_space,
                    MemoryRegion *ram_memory)
{
    PCIBus *b;
    PCIDevice *d;
    PCIHostState *s;
    PCII440FXState *f;
    unsigned i;
    I440FXState *i440fx;

    s = PCI_HOST_BRIDGE(dev);
    b = pci_root_bus_new(dev, NULL, pci_address_space,
                         address_space_io, 0, TYPE_PCI_BUS);
    s-&gt;bus = b;
    object_property_add_child(qdev_get_machine(), &quot;i440fx&quot;, OBJECT(dev));
    sysbus_realize_and_unref(SYS_BUS_DEVICE(dev), &amp;error_fatal);

    d = pci_create_simple(b, 0, pci_type);
    f = I440FX_PCI_DEVICE(d);
</code></pre><p><code>pci_root_bus_new</code> eventually calls <code>pci_root_bus_internal_init</code> which registers the root bus.</p>
<pre tabindex="0"><code>static void pci_root_bus_internal_init(PCIBus *bus, DeviceState *parent,
                                       MemoryRegion *address_space_mem,
                                       MemoryRegion *address_space_io,
                                       uint8_t devfn_min)
{
    assert(PCI_FUNC(devfn_min) == 0);
    bus-&gt;devfn_min = devfn_min;
    bus-&gt;slot_reserved_mask = 0x0;
    bus-&gt;address_space_mem = address_space_mem;
    bus-&gt;address_space_io = address_space_io;
    bus-&gt;flags |= PCI_BUS_IS_ROOT;

    /* host bridge */
    QLIST_INIT(&amp;bus-&gt;child);

    pci_host_bus_register(parent);
}
</code></pre><p>Side note,  i440fx calls <code>pci_create_simple</code> to create devices which goes to Qemu PCI subsystem and eventually call back the i440fx_realize on these devices.</p>
<pre tabindex="0"><code>0  i440fx_realize (dev=0x555556e6b620, errp=0x7fffffffd5c0) at ../hw/pci-host/i440fx.c:233
#1  0x0000555555a072ea in pci_qdev_realize (qdev=0x555556e6b620, errp=0x7fffffffd640) at ../hw/pci/pci.c:2098
#2  0x0000555555e16107 in device_set_realized (obj=0x555556e6b620, value=true, errp=0x7fffffffd750) at ../hw/core/qdev.c:510
#3  0x0000555555e202e3 in property_set_bool (obj=0x555556e6b620, v=0x555556e6fbb0, name=0x555556208211 &quot;realized&quot;, opaque=0x555556a3da90, errp=0x7fffffffd750) at ../qom/object.c:2285
#4  0x0000555555e1e1da in object_property_set (obj=0x555556e6b620, name=0x555556208211 &quot;realized&quot;, v=0x555556e6fbb0, errp=0x7fffffffd750) at ../qom/object.c:1420
#5  0x0000555555e22829 in object_property_set_qobject (obj=0x555556e6b620, name=0x555556208211 &quot;realized&quot;, value=0x555556e6b220, errp=0x5555569bc2e0 &lt;error_fatal&gt;) at ../qom/qom-qobject.c:28
#6  0x0000555555e1e559 in object_property_set_bool (obj=0x555556e6b620, name=0x555556208211 &quot;realized&quot;, value=true, errp=0x5555569bc2e0 &lt;error_fatal&gt;) at ../qom/object.c:1489
#7  0x0000555555e15895 in qdev_realize (dev=0x555556e6b620, bus=0x555556e33b40, errp=0x5555569bc2e0 &lt;error_fatal&gt;) at ../hw/core/qdev.c:292
#8  0x0000555555e158c6 in qdev_realize_and_unref (dev=0x555556e6b620, bus=0x555556e33b40, errp=0x5555569bc2e0 &lt;error_fatal&gt;) at ../hw/core/qdev.c:299
#9  0x0000555555a075f9 in pci_realize_and_unref (dev=0x555556e6b620, bus=0x555556e33b40, errp=0x5555569bc2e0 &lt;error_fatal&gt;) at ../hw/pci/pci.c:2167
#10 0x0000555555a07649 in pci_create_simple_multifunction (bus=0x555556e33b40, devfn=0, multifunction=false, name=0x5555561acef2 &quot;i440FX&quot;) at ../hw/pci/pci.c:2175
#11 0x0000555555a07681 in pci_create_simple (bus=0x555556e33b40, devfn=0, name=0x5555561acef2 &quot;i440FX&quot;) at ../hw/pci/pci.c:2181
#12 0x0000555555a2158b in i440fx_init
    (pci_type=0x5555561acef2 &quot;i440FX&quot;, dev=0x555556d32620, address_space_mem=0x555556c6dc00, address_space_io=0x555556bbc2e0, ram_size=2147483648, below_4g_mem_size=2147483648, above_4g_mem_size=0, pci_address_space=0x555556b6d800, ram_m4
#13 0x0000555555bd8a72 in pc_init1 (machine=0x555556c88400, host_type=0x5555561acef9 &quot;i440FX-pcihost&quot;, pci_type=0x5555561acef2 &quot;i440FX&quot;) at ../hw/i386/pc_piix.c:227
#14 0x0000555555bd9563 in pc_init_v8_0 (machine=0x555556c88400) at ../hw/i386/pc_piix.c:464
#15 0x00005555558f0a19 in machine_run_board_init (machine=0x555556c88400, mem_path=0x0, errp=0x5555569bc2e0 &lt;error_fatal&gt;) at ../hw/core/machine.c:1408
#16 0x0000555555b0df44 in qemu_init_board () at ../softmmu/vl.c:2513
#17 0x0000555555b0e1e5 in qmp_x_exit_preconfig (errp=0x5555569bc2e0 &lt;error_fatal&gt;) at ../softmmu/vl.c:2609
#18 0x0000555555b10a97 in qemu_init (argc=10, argv=0x7fffffffdea8) at ../softmmu/vl.c:3612
#19 0x000055555585c6cb in main (argc=10, argv=0x7fffffffdea8) at ../softmmu/main.c:47

</code></pre><h1 id="run-time">Run time</h1>
<p>During kernel execution, Qemu traps the IO/Memory access to emulate them for the guest kernel. I found <code>i440fx_write_config</code> callback in i440fx which handles memory/IO write</p>
<pre tabindex="0"><code>#0  i440fx_write_config (dev=0x555556e6b620, address=88, val=858992640, len=4) at ../hw/pci-host/i440fx.c:88
#1  0x0000555555a0acf1 in pci_host_config_write_common (pci_dev=0x555556e6b620, addr=88, limit=256, val=858992640, len=4) at ../hw/pci/pci_host.c:85
#2  0x0000555555a0af0f in pci_data_write (s=0x555556e33b40, addr=2147483736, val=858992640, len=4) at ../hw/pci/pci_host.c:127
#3  0x0000555555a0b0b6 in pci_host_data_write (opaque=0x555556d32620, addr=0, val=858992640, len=4) at ../hw/pci/pci_host.c:177
#4  0x0000555555d58118 in memory_region_write_accessor (mr=0x555556d32a60, addr=0, value=0x7ffff6b08068, size=4, shift=0, mask=4294967295, attrs=...) at ../softmmu/memory.c:493
#5  0x0000555555d58366 in access_with_adjusted_size (addr=0, value=0x7ffff6b08068, size=4, access_size_min=1, access_size_max=4, access_fn=0x555555d5801e &lt;memory_region_write_accessor&gt;, mr=0x555556d32a60, attrs=...)
    at ../softmmu/memory.c:555
#6  0x0000555555d5b549 in memory_region_dispatch_write (mr=0x555556d32a60, addr=0, data=858992640, op=MO_32, attrs=...) at ../softmmu/memory.c:1515
#7  0x0000555555d6ad14 in address_space_stl_internal (as=0x55555699e120 &lt;address_space_io&gt;, addr=3324, val=858992640, attrs=..., result=0x0, endian=DEVICE_NATIVE_ENDIAN) at /home/aa/Downloads/sources/qemu/memory_ldst.c.inc:319
#8  0x0000555555d6ae0f in address_space_stl (as=0x55555699e120 &lt;address_space_io&gt;, addr=3324, val=858992640, attrs=..., result=0x0) at /home/aa/Downloads/sources/qemu/memory_ldst.c.inc:350
#9  0x0000555555bc3bb8 in helper_outl (env=0x555556cb1470, port=3324, data=858992640) at ../target/i386/tcg/sysemu/misc_helper.c:55
#10 0x00007fff772b11a0 in code_gen_buffer ()
#11 0x0000555555dd8a3d in cpu_tb_exec (cpu=0x555556caf080, itb=0x7fffb395cfc0, tb_exit=0x7ffff6b086f8) at ../accel/tcg/cpu-exec.c:460
#12 0x0000555555dd97cf in cpu_loop_exec_tb (cpu=0x555556caf080, tb=0x7fffb395cfc0, pc=4294884085, last_tb=0x7ffff6b08708, tb_exit=0x7ffff6b086f8) at ../accel/tcg/cpu-exec.c:894
#13 0x0000555555dd9aeb in cpu_exec_loop (cpu=0x555556caf080, sc=0x7ffff6b08780) at ../accel/tcg/cpu-exec.c:1005
#14 0x0000555555dd9c39 in cpu_exec_setjmp (cpu=0x555556caf080, sc=0x7ffff6b08780) at ../accel/tcg/cpu-exec.c:1037
#15 0x0000555555dd9ccf in cpu_exec (cpu=0x555556caf080) at ../accel/tcg/cpu-exec.c:1063
#16 0x0000555555e08813 in tcg_cpus_exec (cpu=0x555556caf080) at ../accel/tcg/tcg-accel-ops.c:81
#17 0x0000555555e08efb in mttcg_cpu_thread_fn (arg=0x555556caf080) at ../accel/tcg/tcg-accel-ops-mttcg.c:95
#18 0x00005555560021bb in qemu_thread_start (args=0x555556d07620) at ../util/qemu-thread-posix.c:541
#19 0x00007ffff77b8b43 in start_thread (arg=&lt;optimized out&gt;) at ./nptl/pthread_create.c:442
#20 0x00007ffff784aa00 in clone3 () at ../sysdeps/unix/sysv/linux/x86_64/clone3.S:81

</code></pre><p>i440fx_write_config calls pci_default_write_config</p>
<pre tabindex="0"><code>static void i440fx_write_config(PCIDevice *dev,
                                uint32_t address, uint32_t val, int len)
{
    PCII440FXState *d = I440FX_PCI_DEVICE(dev);

    /* XXX: implement SMRAM.D_LOCK */
    pci_default_write_config(dev, address, val, len);
    if (ranges_overlap(address, len, I440FX_PAM, I440FX_PAM_SIZE) ||
        range_covers_byte(address, len, I440FX_SMRAM)) {
        i440fx_update_memory_mappings(d);
    }
}
</code></pre><p>and pci_default_write_config eventually call pci_host_config_write to set the value of the emulated register. For completeness, I copied <code>pci_host_config_read</code> as well.</p>
<pre tabindex="0"><code>static void pci_host_config_write(void *opaque, hwaddr addr,
                                  uint64_t val, unsigned len)
{
    PCIHostState *s = opaque;

    PCI_DPRINTF(&quot;%s addr &quot; HWADDR_FMT_plx &quot; len %d val %&quot;PRIx64&quot;\n&quot;,
                __func__, addr, len, val);
    if (addr != 0 || len != 4) {
        return;
    }
    s-&gt;config_reg = val;
}

static uint64_t pci_host_config_read(void *opaque, hwaddr addr,
                                     unsigned len)
{
    PCIHostState *s = opaque;
    uint32_t val = s-&gt;config_reg;

    PCI_DPRINTF(&quot;%s addr &quot; HWADDR_FMT_plx &quot; len %d val %&quot;PRIx32&quot;\n&quot;,
                __func__, addr, len, val);
    return val;
}
</code></pre><p>To sum up, There are 2 stages here:</p>
<ul>
<li>The board initialization where PCI topology is create starting with host bridge and other buses and devices</li>
<li>During the time, Qemu (while doing code translation using the wonderful TCG) traps the memory/IO operations and redirect them into the devices created in the initialization above.</li>
</ul>
<p>That&rsquo;s it.</p>

      </div>
    </article>

    <hr />

    <div class="post-info">
      
    <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line></svg>

        <span class="tag"><a href="tags/qemu/">qemu</a></span>
        
    </p>

      

      <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text">
          <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
          <polyline points="14 2 14 8 20 8"></polyline>
          <line x1="16" y1="13" x2="8" y2="13"></line>
          <line x1="16" y1="17" x2="8" y2="17"></line>
          <polyline points="10 9 9 9 8 9"></polyline>
        </svg>
        1030 Words
      </p>

      <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar">
          <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
          <line x1="16" y1="2" x2="16" y2="6"></line>
          <line x1="8" y1="2" x2="8" y2="6"></line>
          <line x1="3" y1="10" x2="21" y2="10"></line>
        </svg>
        
          2023-03-19 00:00 &#43;0000
        

         
          
        
      </p>
    </div>

    
      <div class="pagination">
        <div class="pagination__title">
          <span class="pagination__title-h">Read other posts</span>
          <hr />
        </div>

        <div class="pagination__buttons">
          
            <span class="button previous">
              <a href="/posts/2023/03/misc-useful-commands/">
                <span class="button__icon">←</span>
                <span class="button__text">Misc useful commands</span>
              </a>
            </span>
          

          
            <span class="button next">
              <a href="/posts/2023/03/crypto-big-picture/">
                <span class="button__text">Crypto - big Picture</span>
                <span class="button__icon">→</span>
              </a>
            </span>
          
        </div>
      </div>
    


    

    

  </main>

            </div>

            
                <footer class="footer">
    <div class="footer__inner">
        <div class="footer__content">
            <span>&copy; 2023</span>
            
            <span><a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0</a></span><span><a href="posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a></span>
        </div>
    </div>
    <div class="footer__inner">
        <div class="footer__content">
            <span>Powered by <a href="http://gohugo.io">Hugo</a></span>
            <span>Made with &#10084; by <a href="https://github.com/rhazdon">Djordje Atlialp</a></span>
          </div>
    </div>
</footer>

            
        </div>

        



<script type="text/javascript" src="/bundle.min.2ce64ea6ea44a72b13dd812fc2eb5cca3efe878cce258a47c137c17edf46e0602a05e422b618a5b80b5939c731b7a293351c2f2222a21f6ee27e54a8448dd20e.js" integrity="sha512-LOZOpupEpysT3YEvwutcyj7&#43;h4zOJYpHwTfBft9G4GAqBeQithiluAtZOccxt6KTNRwvIiKiH27iflSoRI3SDg=="></script>



    </body>
</html>
