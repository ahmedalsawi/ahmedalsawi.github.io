<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="author" content="">
<meta name="description" content="This is a quick write-up about SRIOV and virtual functions emulation in Qemu. From link
 SR-IOV is a specification that allows a single Peripheral Component Interconnect Express (PCIe) physical device under a single root port to appear as multiple separate physical devices to the hypervisor or the guest operating system.
SR-IOV uses physical functions (PFs) and virtual functions (VFs) to manage global functions for the SR-IOV devices. PFs are full PCIe functions that are capable of configuring and managing the SR-IOV functionality." />
<meta name="keywords" content=", qemu, pcie" />
<meta name="robots" content="noodp" />
<meta name="theme-color" content="" />
<link rel="canonical" href="/posts/2023/04/qemu-pcie-sriov-and-virtual-function/" />


    <title>
        
            Qemu - PCIe SRIOV and virtual function :: Techiedeepdive 
        
    </title>



<link href="https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.5.0/css/flag-icon.min.css" rel="stylesheet"
    type="text/css">



<link rel="stylesheet" href="/main.de188b3201233c251f4fd6306dbd2cb41e408fb8846c09781b2925de7df5025c.css">






<meta itemprop="name" content="Qemu - PCIe SRIOV and virtual function">
<meta itemprop="description" content="This is a quick write-up about SRIOV and virtual functions emulation in Qemu. From link
 SR-IOV is a specification that allows a single Peripheral Component Interconnect Express (PCIe) physical device under a single root port to appear as multiple separate physical devices to the hypervisor or the guest operating system.
SR-IOV uses physical functions (PFs) and virtual functions (VFs) to manage global functions for the SR-IOV devices. PFs are full PCIe functions that are capable of configuring and managing the SR-IOV functionality."><meta itemprop="datePublished" content="2023-04-01T00:00:00+00:00" />
<meta itemprop="dateModified" content="2023-04-01T00:00:00+00:00" />
<meta itemprop="wordCount" content="887"><meta itemprop="image" content=""/>
<meta itemprop="keywords" content="qemu,pcie," />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content=""/>

<meta name="twitter:title" content="Qemu - PCIe SRIOV and virtual function"/>
<meta name="twitter:description" content="This is a quick write-up about SRIOV and virtual functions emulation in Qemu. From link
 SR-IOV is a specification that allows a single Peripheral Component Interconnect Express (PCIe) physical device under a single root port to appear as multiple separate physical devices to the hypervisor or the guest operating system.
SR-IOV uses physical functions (PFs) and virtual functions (VFs) to manage global functions for the SR-IOV devices. PFs are full PCIe functions that are capable of configuring and managing the SR-IOV functionality."/>




    <meta property="og:title" content="Qemu - PCIe SRIOV and virtual function" />
<meta property="og:description" content="This is a quick write-up about SRIOV and virtual functions emulation in Qemu. From link
 SR-IOV is a specification that allows a single Peripheral Component Interconnect Express (PCIe) physical device under a single root port to appear as multiple separate physical devices to the hypervisor or the guest operating system.
SR-IOV uses physical functions (PFs) and virtual functions (VFs) to manage global functions for the SR-IOV devices. PFs are full PCIe functions that are capable of configuring and managing the SR-IOV functionality." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/2023/04/qemu-pcie-sriov-and-virtual-function/" /><meta property="og:image" content=""/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-01T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-04-01T00:00:00+00:00" /><meta property="og:site_name" content="Techiedeepdive" />







    <meta property="article:published_time" content="2023-04-01 00:00:00 &#43;0000 UTC" />








    </head>

    
        <body>
    
    
        <div class="container">
            <header class="header">
    <span class="header__inner">
        <a href="/" style="text-decoration: none;">
    <div class="logo">
        
            <span class="logo__mark">></span>
            <span class="logo__text">$ cd /home/</span>
            <span class="logo__cursor" style=
                  "
                   
                   ">
            </span>
        
    </div>
</a>


        <span class="header__right">
            
                <nav class="menu">
    <ul class="menu__inner"><li><a href="/about/">About</a></li><li><a href="/posts">Blog</a></li><li><a href="/reading-list/">Reading list</a></li><li><a href="/tags/">Tags</a></li>
    </ul>
</nav>

                <span class="menu-trigger">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                        <path d="M0 0h24v24H0z" fill="none"/>
                        <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
                    </svg>
                </span>
            
        </span>
    </span>
</header>


            <div class="content">
                
  <main class="post">

    <div class="post-info">
      <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock">
          <circle cx="12" cy="12" r="10"></circle>
          <polyline points="12 6 12 12 16 14"></polyline>
        </svg>
        5 minutes

        
      </p>
    </div>

    <article>
      <h1 class="post-title">
        <a href="/posts/2023/04/qemu-pcie-sriov-and-virtual-function/">Qemu - PCIe SRIOV and virtual function</a>
      </h1>

      

      

      <div class="post-content">
        <p>This is a quick write-up about SRIOV and virtual functions emulation in Qemu. From <a href="https://docs.vmware.com/en/VMware-vSphere/7.0/com.vmware.vsphere.networking.doc/GUID-CC021803-30EA-444D-BCBE-618E0D836B9F.html">link</a></p>
<blockquote>
<p>SR-IOV is a specification that allows a single Peripheral Component Interconnect Express (PCIe) physical device under a single root port to appear as multiple separate physical devices to the hypervisor or the guest operating system.</p>
<p>SR-IOV uses physical functions (PFs) and virtual functions (VFs) to manage global functions for the SR-IOV devices. PFs are full PCIe functions that are capable of configuring and managing the SR-IOV functionality. It is possible to configure or control PCIe devices using PFs, and the PF has full ability to move data in and out of the device. VFs are lightweight PCIe functions that support data flowing but have a restricted set of configuration resources.</p>
</blockquote>
<h1 id="device-emulation-igb">Device emulation igb</h1>
<p>Let&rsquo;s Have a look at an example of Network device that supports SRIOV. In <code>hw/net/igb.c</code>, igb is one of the Intel NIC&rsquo;s that supports SRIOV. The emulation calls these functions to init the SRIOV capability and BAR</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">    pcie_sriov_pf_init(pci_dev, IGB_CAP_SRIOV_OFFSET, <span style="color:#0ff;font-weight:bold">&#34;igbvf&#34;</span>,
        IGB_82576_VF_DEV_ID, IGB_MAX_VF_FUNCTIONS, IGB_MAX_VF_FUNCTIONS,
        IGB_VF_OFFSET, IGB_VF_STRIDE);

    pcie_sriov_pf_init_vf_bar(pci_dev, <span style="color:#ff0;font-weight:bold">0</span>,
        PCI_BASE_ADDRESS_MEM_TYPE_64 | PCI_BASE_ADDRESS_MEM_PREFETCH,
        <span style="color:#ff0;font-weight:bold">16</span> * KiB);
    pcie_sriov_pf_init_vf_bar(pci_dev, <span style="color:#ff0;font-weight:bold">3</span>,
        PCI_BASE_ADDRESS_MEM_TYPE_64 | PCI_BASE_ADDRESS_MEM_PREFETCH,
        <span style="color:#ff0;font-weight:bold">16</span> * KiB);
</code></pre></div><h1 id="sriov-subsystem">sriov subsystem</h1>
<p>In <code>hw/pci/pcie_sriov.c</code>, <code>pcie_sriov_pf_init</code> sets the configuration spaces for SRIOV capability.</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">void</span> pcie_sriov_pf_init(PCIDevice *dev, <span style="color:#fff;font-weight:bold">uint16_t</span> offset,
                        <span style="color:#fff;font-weight:bold">const</span> <span style="color:#fff;font-weight:bold">char</span> *vfname, <span style="color:#fff;font-weight:bold">uint16_t</span> vf_dev_id,
                        <span style="color:#fff;font-weight:bold">uint16_t</span> init_vfs, <span style="color:#fff;font-weight:bold">uint16_t</span> total_vfs,
                        <span style="color:#fff;font-weight:bold">uint16_t</span> vf_offset, <span style="color:#fff;font-weight:bold">uint16_t</span> vf_stride)
{
    <span style="color:#fff;font-weight:bold">uint8_t</span> *cfg = dev-&gt;config + offset;
    <span style="color:#fff;font-weight:bold">uint8_t</span> *wmask;

    pcie_add_capability(dev, PCI_EXT_CAP_ID_SRIOV, <span style="color:#ff0;font-weight:bold">1</span>,
                        offset, PCI_EXT_CAP_SRIOV_SIZEOF);
      
    dev-&gt;exp.sriov_cap = offset;
    dev-&gt;exp.sriov_pf.num_vfs = <span style="color:#ff0;font-weight:bold">0</span>;
    dev-&gt;exp.sriov_pf.vfname = g_strdup(vfname);
    dev-&gt;exp.sriov_pf.vf = <span style="color:#fff;font-weight:bold">NULL</span>;

    pci_set_word(cfg + PCI_SRIOV_VF_OFFSET, vf_offset);
    pci_set_word(cfg + PCI_SRIOV_VF_STRIDE, vf_stride);

    pci_set_word(cfg + PCI_SRIOV_SUP_PGSIZE, SRIOV_SUP_PGSIZE_MINREQ);

    pci_set_word(cfg + PCI_SRIOV_SYS_PGSIZE, <span style="color:#ff0;font-weight:bold">0x1</span>);

    pci_set_word(cfg + PCI_SRIOV_VF_DID, vf_dev_id);
    pci_set_word(cfg + PCI_SRIOV_INITIAL_VF, init_vfs);
    pci_set_word(cfg + PCI_SRIOV_TOTAL_VF, total_vfs);
    pci_set_word(cfg + PCI_SRIOV_NUM_VF, <span style="color:#ff0;font-weight:bold">0</span>);

    wmask = dev-&gt;wmask + offset;
    pci_set_word(wmask + PCI_SRIOV_CTRL,
                 PCI_SRIOV_CTRL_VFE | PCI_SRIOV_CTRL_MSE | PCI_SRIOV_CTRL_ARI);
    pci_set_word(wmask + PCI_SRIOV_NUM_VF, <span style="color:#ff0;font-weight:bold">0xffff</span>);
    pci_set_word(wmask + PCI_SRIOV_SYS_PGSIZE, <span style="color:#ff0;font-weight:bold">0x553</span>);

    qdev_prop_set_bit(&amp;dev-&gt;qdev, <span style="color:#0ff;font-weight:bold">&#34;multifunction&#34;</span>, <span style="color:#fff;font-weight:bold">true</span>);
}
</code></pre></div><p><code>pcie_sriov_pf_init_vf_bar</code> is called with devices to set BAR mask and configuration.</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">void</span> pcie_sriov_pf_init_vf_bar(PCIDevice *dev, <span style="color:#fff;font-weight:bold">int</span> region_num,
                               <span style="color:#fff;font-weight:bold">uint8_t</span> type, dma_addr_t size)
{

  ...
  ...
    wmask = ~(size - <span style="color:#ff0;font-weight:bold">1</span>);
    addr = sriov_cap + PCI_SRIOV_BAR + region_num * <span style="color:#ff0;font-weight:bold">4</span>;

    pci_set_long(dev-&gt;config + addr, type);
    <span style="color:#fff;font-weight:bold">if</span> (!(type &amp; PCI_BASE_ADDRESS_SPACE_IO) &amp;&amp;
        type &amp; PCI_BASE_ADDRESS_MEM_TYPE_64) {
        pci_set_quad(dev-&gt;wmask + addr, wmask);
        pci_set_quad(dev-&gt;cmask + addr, ~<span style="color:#ff0;font-weight:bold">0ULL</span>);
    } <span style="color:#fff;font-weight:bold">else</span> {
        pci_set_long(dev-&gt;wmask + addr, wmask &amp; <span style="color:#ff0;font-weight:bold">0xffffffff</span>);
        pci_set_long(dev-&gt;cmask + addr, <span style="color:#ff0;font-weight:bold">0xffffffff</span>);
    }
    dev-&gt;exp.sriov_pf.vf_bar_type[region_num] = type;
}
</code></pre></div><h1 id="pci-methods-accessing-vf-address-space">pci methods accessing VF address space</h1>
<p>In <code>hw/pci/pci.c</code>, <code>pci_config_get_bar_addr</code> is called by the generic pci subsystem. But the virtual function has special handling.</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">static</span> pcibus_t pci_config_get_bar_addr(PCIDevice *d, <span style="color:#fff;font-weight:bold">int</span> reg,
                                        <span style="color:#fff;font-weight:bold">uint8_t</span> type, pcibus_t size)
{
    pcibus_t new_addr;
    <span style="color:#fff;font-weight:bold">if</span> (!pci_is_vf(d)) {
      ...
      ...
    } <span style="color:#fff;font-weight:bold">else</span> {
        PCIDevice *pf = d-&gt;exp.sriov_vf.pf;
        <span style="color:#fff;font-weight:bold">uint16_t</span> sriov_cap = pf-&gt;exp.sriov_cap;
        <span style="color:#fff;font-weight:bold">int</span> bar = sriov_cap + PCI_SRIOV_BAR + reg * <span style="color:#ff0;font-weight:bold">4</span>;
        <span style="color:#fff;font-weight:bold">uint16_t</span> vf_offset =
            pci_get_word(pf-&gt;config + sriov_cap + PCI_SRIOV_VF_OFFSET);
        <span style="color:#fff;font-weight:bold">uint16_t</span> vf_stride =
            pci_get_word(pf-&gt;config + sriov_cap + PCI_SRIOV_VF_STRIDE);
        <span style="color:#fff;font-weight:bold">uint32_t</span> vf_num = (d-&gt;devfn - (pf-&gt;devfn + vf_offset)) / vf_stride;

        <span style="color:#fff;font-weight:bold">if</span> (type &amp; PCI_BASE_ADDRESS_MEM_TYPE_64) {
            new_addr = pci_get_quad(pf-&gt;config + bar);
        } <span style="color:#fff;font-weight:bold">else</span> {
            new_addr = pci_get_long(pf-&gt;config + bar);
        }
        new_addr += vf_num * size;
    }
    ...
    ...
}
</code></pre></div><h1 id="enable-and-disable-devices">Enable and disable devices</h1>
<p>Still in pci subsystem, In <code>pci_default_write_config</code>, sriov had to be handled differently by calling <code>pcie_sriov_config_writ</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">void</span> pci_default_write_config(PCIDevice *d, <span style="color:#fff;font-weight:bold">uint32_t</span> addr, <span style="color:#fff;font-weight:bold">uint32_t</span> val_in, <span style="color:#fff;font-weight:bold">int</span> l)
{
...
...
    pcie_sriov_config_write(d, addr, val_in, l);
}
</code></pre></div><p>The config enables and disables the device by calling <code>register_vfs</code> and <code>unregister_vfs</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">void</span> pcie_sriov_config_write(PCIDevice *dev, <span style="color:#fff;font-weight:bold">uint32_t</span> address,
                             <span style="color:#fff;font-weight:bold">uint32_t</span> val, <span style="color:#fff;font-weight:bold">int</span> len)
{
    <span style="color:#fff;font-weight:bold">uint32_t</span> off;
    <span style="color:#fff;font-weight:bold">uint16_t</span> sriov_cap = dev-&gt;exp.sriov_cap;

    <span style="color:#fff;font-weight:bold">if</span> (!sriov_cap || address &lt; sriov_cap) {
        <span style="color:#fff;font-weight:bold">return</span>;
    }
    off = address - sriov_cap;
    <span style="color:#fff;font-weight:bold">if</span> (off &gt;= PCI_EXT_CAP_SRIOV_SIZEOF) {
        <span style="color:#fff;font-weight:bold">return</span>;
    }

    trace_sriov_config_write(dev-&gt;name, PCI_SLOT(dev-&gt;devfn),
                             PCI_FUNC(dev-&gt;devfn), off, val, len);

    <span style="color:#fff;font-weight:bold">if</span> (range_covers_byte(off, len, PCI_SRIOV_CTRL)) {
        <span style="color:#fff;font-weight:bold">if</span> (dev-&gt;exp.sriov_pf.num_vfs) {
            <span style="color:#fff;font-weight:bold">if</span> (!(val &amp; PCI_SRIOV_CTRL_VFE)) {
                unregister_vfs(dev);
            }
        } <span style="color:#fff;font-weight:bold">else</span> {
            <span style="color:#fff;font-weight:bold">if</span> (val &amp; PCI_SRIOV_CTRL_VFE) {
                register_vfs(dev);
            }
        }
    }
}
</code></pre></div><p>In <code>register_vfs</code> and <code>unregister_vfs</code>, the virtual functions are enabled and disabled.</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">static</span> PCIDevice *register_vf(PCIDevice *pf, <span style="color:#fff;font-weight:bold">int</span> devfn, <span style="color:#fff;font-weight:bold">const</span> <span style="color:#fff;font-weight:bold">char</span> *name,
                              <span style="color:#fff;font-weight:bold">uint16_t</span> vf_num)
{
    PCIDevice *dev = pci_new(devfn, name);
    dev-&gt;exp.sriov_vf.pf = pf;
    dev-&gt;exp.sriov_vf.vf_number = vf_num;
    PCIBus *bus = pci_get_bus(pf);
    Error *local_err = <span style="color:#fff;font-weight:bold">NULL</span>;

    ...
    ...
    qdev_realize(&amp;dev-&gt;qdev, &amp;bus-&gt;qbus, &amp;local_err);

    <span style="color:#007f7f">/* set vid/did according to sr/iov spec - they are not used */</span>
    pci_config_set_vendor_id(dev-&gt;config, <span style="color:#ff0;font-weight:bold">0xffff</span>);
    pci_config_set_device_id(dev-&gt;config, <span style="color:#ff0;font-weight:bold">0xffff</span>);

    <span style="color:#fff;font-weight:bold">return</span> dev;
}

<span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">void</span> register_vfs(PCIDevice *dev)
{
    <span style="color:#fff;font-weight:bold">uint16_t</span> sriov_cap = dev-&gt;exp.sriov_cap;
    <span style="color:#fff;font-weight:bold">uint16_t</span> vf_offset = pci_get_word(dev-&gt;config + sriov_cap + PCI_SRIOV_VF_OFFSET);
    <span style="color:#fff;font-weight:bold">uint16_t</span> vf_stride = pci_get_word(dev-&gt;config + sriov_cap + PCI_SRIOV_VF_STRIDE);
    <span style="color:#fff;font-weight:bold">int32_t</span> devfn = dev-&gt;devfn + vf_offset;


    num_vfs = pci_get_word(dev-&gt;config + sriov_cap + PCI_SRIOV_NUM_VF);

    dev-&gt;exp.sriov_pf.vf = g_new(PCIDevice *, num_vfs);

    trace_sriov_register_vfs(dev-&gt;name, PCI_SLOT(dev-&gt;devfn),
                             PCI_FUNC(dev-&gt;devfn), num_vfs);
    <span style="color:#fff;font-weight:bold">for</span> (i = <span style="color:#ff0;font-weight:bold">0</span>; i &lt; num_vfs; i++) {
        dev-&gt;exp.sriov_pf.vf[i] = register_vf(dev, devfn,
                                              dev-&gt;exp.sriov_pf.vfname, i);
        <span style="color:#fff;font-weight:bold">if</span> (!dev-&gt;exp.sriov_pf.vf[i]) {
            num_vfs = i;
            <span style="color:#fff;font-weight:bold">break</span>;
        }
        devfn += vf_stride;
    }
    dev-&gt;exp.sriov_pf.num_vfs = num_vfs;
}

<span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">void</span> unregister_vfs(PCIDevice *dev)
{
    ...
    ...
    <span style="color:#fff;font-weight:bold">uint16_t</span> num_vfs = dev-&gt;exp.sriov_pf.num_vfs;

    trace_sriov_unregister_vfs(dev-&gt;name, PCI_SLOT(dev-&gt;devfn),
                               PCI_FUNC(dev-&gt;devfn), num_vfs);
    <span style="color:#fff;font-weight:bold">for</span> (i = <span style="color:#ff0;font-weight:bold">0</span>; i &lt; num_vfs; i++) {
        PCIDevice *vf = dev-&gt;exp.sriov_pf.vf[i];
        object_property_set_bool(OBJECT(vf), <span style="color:#0ff;font-weight:bold">&#34;realized&#34;</span>, <span style="color:#fff;font-weight:bold">false</span>, &amp;local_err);
        ...
        ...
    }
    g_free(dev-&gt;exp.sriov_pf.vf);
    dev-&gt;exp.sriov_pf.vf = <span style="color:#fff;font-weight:bold">NULL</span>;
    dev-&gt;exp.sriov_pf.num_vfs = <span style="color:#ff0;font-weight:bold">0</span>;
    pci_set_word(dev-&gt;config + dev-&gt;exp.sriov_cap + PCI_SRIOV_NUM_VF, <span style="color:#ff0;font-weight:bold">0</span>);
}
</code></pre></div><h1 id="multifunction-and-virtual-functions">multifunction and virtual functions</h1>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">void</span> pci_init_multifunction(PCIBus *bus, PCIDevice *dev, Error **errp)
{
    <span style="color:#fff;font-weight:bold">uint8_t</span> slot = PCI_SLOT(dev-&gt;devfn);
    <span style="color:#fff;font-weight:bold">uint8_t</span> func;

    <span style="color:#fff;font-weight:bold">if</span> (dev-&gt;cap_present &amp; QEMU_PCI_CAP_MULTIFUNCTION) {
        dev-&gt;config[PCI_HEADER_TYPE] |= PCI_HEADER_TYPE_MULTI_FUNCTION;
    }

    <span style="color:#007f7f">/*
</span><span style="color:#007f7f">     * With SR/IOV and ARI, a device at function 0 need not be a multifunction
</span><span style="color:#007f7f">     * device, as it may just be a VF that ended up with function 0 in
</span><span style="color:#007f7f">     * the legacy PCI interpretation. Avoid failing in such cases:
</span><span style="color:#007f7f">     */</span>
    <span style="color:#fff;font-weight:bold">if</span> (pci_is_vf(dev) &amp;&amp;
        dev-&gt;exp.sriov_vf.pf-&gt;cap_present &amp; QEMU_PCI_CAP_MULTIFUNCTION) {
        <span style="color:#fff;font-weight:bold">return</span>;
    }

</code></pre></div>
      </div>
    </article>

    <hr />

    <div class="post-info">
      
    <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line></svg>

        <span class="tag"><a href="tags/qemu/">qemu</a></span>
        <span class="tag"><a href="tags/pcie/">pcie</a></span>
        
    </p>

      

      <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text">
          <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
          <polyline points="14 2 14 8 20 8"></polyline>
          <line x1="16" y1="13" x2="8" y2="13"></line>
          <line x1="16" y1="17" x2="8" y2="17"></line>
          <polyline points="10 9 9 9 8 9"></polyline>
        </svg>
        887 Words
      </p>

      <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar">
          <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
          <line x1="16" y1="2" x2="16" y2="6"></line>
          <line x1="8" y1="2" x2="8" y2="6"></line>
          <line x1="3" y1="10" x2="21" y2="10"></line>
        </svg>
        
          2023-04-01 01:00 &#43;0100
        

         
          
        
      </p>
    </div>

    
      <div class="pagination">
        <div class="pagination__title">
          <span class="pagination__title-h">Read other posts</span>
          <hr />
        </div>

        <div class="pagination__buttons">
          
            <span class="button previous">
              <a href="/posts/2023/04/qemu-data-object-exchange-doe/">
                <span class="button__icon">←</span>
                <span class="button__text">Qemu - Data object exchange DOE</span>
              </a>
            </span>
          

          
            <span class="button next">
              <a href="/posts/2023/03/qemu-riscv-emulation/">
                <span class="button__text">Qemu riscv emulation</span>
                <span class="button__icon">→</span>
              </a>
            </span>
          
        </div>
      </div>
    


    

    

  </main>

            </div>

            
                <footer class="footer">
    <div class="footer__inner">
        <div class="footer__content">
            <span>&copy; 2023</span>
            
            <span><a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0</a></span><span><a href="posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a></span>
        </div>
    </div>
    <div class="footer__inner">
        <div class="footer__content">
            <span>Powered by <a href="http://gohugo.io">Hugo</a></span>
            <span>Made with &#10084; by <a href="https://github.com/rhazdon">Djordje Atlialp</a></span>
          </div>
    </div>
</footer>

            
        </div>

        



<script type="text/javascript" src="/bundle.min.2ce64ea6ea44a72b13dd812fc2eb5cca3efe878cce258a47c137c17edf46e0602a05e422b618a5b80b5939c731b7a293351c2f2222a21f6ee27e54a8448dd20e.js" integrity="sha512-LOZOpupEpysT3YEvwutcyj7&#43;h4zOJYpHwTfBft9G4GAqBeQithiluAtZOccxt6KTNRwvIiKiH27iflSoRI3SDg=="></script>



    </body>
</html>
