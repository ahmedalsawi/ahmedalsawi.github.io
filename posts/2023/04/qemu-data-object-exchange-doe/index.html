<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="author" content="">
<meta name="description" content="This is a quick write-up about Qemu DOE emulation. DOE is part of PCIe and CXL extended capabilities. Technically, It&amp;rsquo;s optional but is important part of IDE starting gen5.
Starting with cxl_usp_read_config is one of the places where pcie_doe_read_config is called. It seems it&amp;rsquo;s only supported with CXL which kinda matches what kernel implements. If it&amp;rsquo;s DOE extended address, it will fall back to pci_default_read_config.
static uint32_t cxl_usp_read_config(PCIDevice *d, uint32_t address, int len) { CXLUpstreamPort *usp = CXL_USP(d); uint32_t val; if (pcie_doe_read_config(&amp;amp;usp-&amp;gt;doe_cdat, address, len, &amp;amp;val)) { return val; } return pci_default_read_config(d, address, len); } pcie_doe_read_config reads the fields when address matches the DW in DOW extended configuration address space." />
<meta name="keywords" content=", qemu, pcie" />
<meta name="robots" content="noodp" />
<meta name="theme-color" content="" />
<link rel="canonical" href="/posts/2023/04/qemu-data-object-exchange-doe/" />


    <title>
        
            Qemu - Data object exchange DOE :: Techiedeepdive 
        
    </title>



<link href="https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.5.0/css/flag-icon.min.css" rel="stylesheet"
    type="text/css">



<link rel="stylesheet" href="/main.de188b3201233c251f4fd6306dbd2cb41e408fb8846c09781b2925de7df5025c.css">






<meta itemprop="name" content="Qemu - Data object exchange DOE">
<meta itemprop="description" content="This is a quick write-up about Qemu DOE emulation. DOE is part of PCIe and CXL extended capabilities. Technically, It&rsquo;s optional but is important part of IDE starting gen5.
Starting with cxl_usp_read_config is one of the places where pcie_doe_read_config is called. It seems it&rsquo;s only supported with CXL which kinda matches what kernel implements. If it&rsquo;s DOE extended address, it will fall back to pci_default_read_config.
static uint32_t cxl_usp_read_config(PCIDevice *d, uint32_t address, int len) { CXLUpstreamPort *usp = CXL_USP(d); uint32_t val; if (pcie_doe_read_config(&amp;usp-&gt;doe_cdat, address, len, &amp;val)) { return val; } return pci_default_read_config(d, address, len); } pcie_doe_read_config reads the fields when address matches the DW in DOW extended configuration address space."><meta itemprop="datePublished" content="2023-04-01T00:00:00+00:00" />
<meta itemprop="dateModified" content="2023-04-01T00:00:00+00:00" />
<meta itemprop="wordCount" content="628"><meta itemprop="image" content=""/>
<meta itemprop="keywords" content="qemu,pcie," />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content=""/>

<meta name="twitter:title" content="Qemu - Data object exchange DOE"/>
<meta name="twitter:description" content="This is a quick write-up about Qemu DOE emulation. DOE is part of PCIe and CXL extended capabilities. Technically, It&rsquo;s optional but is important part of IDE starting gen5.
Starting with cxl_usp_read_config is one of the places where pcie_doe_read_config is called. It seems it&rsquo;s only supported with CXL which kinda matches what kernel implements. If it&rsquo;s DOE extended address, it will fall back to pci_default_read_config.
static uint32_t cxl_usp_read_config(PCIDevice *d, uint32_t address, int len) { CXLUpstreamPort *usp = CXL_USP(d); uint32_t val; if (pcie_doe_read_config(&amp;usp-&gt;doe_cdat, address, len, &amp;val)) { return val; } return pci_default_read_config(d, address, len); } pcie_doe_read_config reads the fields when address matches the DW in DOW extended configuration address space."/>




    <meta property="og:title" content="Qemu - Data object exchange DOE" />
<meta property="og:description" content="This is a quick write-up about Qemu DOE emulation. DOE is part of PCIe and CXL extended capabilities. Technically, It&rsquo;s optional but is important part of IDE starting gen5.
Starting with cxl_usp_read_config is one of the places where pcie_doe_read_config is called. It seems it&rsquo;s only supported with CXL which kinda matches what kernel implements. If it&rsquo;s DOE extended address, it will fall back to pci_default_read_config.
static uint32_t cxl_usp_read_config(PCIDevice *d, uint32_t address, int len) { CXLUpstreamPort *usp = CXL_USP(d); uint32_t val; if (pcie_doe_read_config(&amp;usp-&gt;doe_cdat, address, len, &amp;val)) { return val; } return pci_default_read_config(d, address, len); } pcie_doe_read_config reads the fields when address matches the DW in DOW extended configuration address space." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/2023/04/qemu-data-object-exchange-doe/" /><meta property="og:image" content=""/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-01T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-04-01T00:00:00+00:00" /><meta property="og:site_name" content="Techiedeepdive" />







    <meta property="article:published_time" content="2023-04-01 00:00:00 &#43;0000 UTC" />








    </head>

    
        <body>
    
    
        <div class="container">
            <header class="header">
    <span class="header__inner">
        <a href="/" style="text-decoration: none;">
    <div class="logo">
        
            <span class="logo__mark">></span>
            <span class="logo__text">$ cd /home/</span>
            <span class="logo__cursor" style=
                  "
                   
                   ">
            </span>
        
    </div>
</a>


        <span class="header__right">
            
                <nav class="menu">
    <ul class="menu__inner"><li><a href="/about/">About</a></li><li><a href="/posts">Blog</a></li><li><a href="/reading-list/">Reading list</a></li><li><a href="/tags/">Tags</a></li>
    </ul>
</nav>

                <span class="menu-trigger">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                        <path d="M0 0h24v24H0z" fill="none"/>
                        <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
                    </svg>
                </span>
            
        </span>
    </span>
</header>


            <div class="content">
                
  <main class="post">

    <div class="post-info">
      <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock">
          <circle cx="12" cy="12" r="10"></circle>
          <polyline points="12 6 12 12 16 14"></polyline>
        </svg>
        3 minutes

        
      </p>
    </div>

    <article>
      <h1 class="post-title">
        <a href="/posts/2023/04/qemu-data-object-exchange-doe/">Qemu - Data object exchange DOE</a>
      </h1>

      

      

      <div class="post-content">
        <p>This is a quick write-up about Qemu DOE emulation. DOE is part of PCIe and CXL extended capabilities. Technically, It&rsquo;s optional but is important part of IDE starting gen5.</p>
<p>Starting with <code>cxl_usp_read_config</code> is one of the places where <code>pcie_doe_read_config</code> is called. It seems it&rsquo;s only supported with CXL which kinda matches what kernel implements. If it&rsquo;s DOE extended address, it will fall back to <code>pci_default_read_config</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">uint32_t</span> cxl_usp_read_config(PCIDevice *d, <span style="color:#fff;font-weight:bold">uint32_t</span> address, <span style="color:#fff;font-weight:bold">int</span> len)
{
    CXLUpstreamPort *usp = CXL_USP(d);
    <span style="color:#fff;font-weight:bold">uint32_t</span> val;

    <span style="color:#fff;font-weight:bold">if</span> (pcie_doe_read_config(&amp;usp-&gt;doe_cdat, address, len, &amp;val)) {
        <span style="color:#fff;font-weight:bold">return</span> val;
    }

    <span style="color:#fff;font-weight:bold">return</span> pci_default_read_config(d, address, len);
}
</code></pre></div><p><code>pcie_doe_read_config</code> reads the fields when address matches the DW in DOW extended configuration address space. Other than configuration access, The important thing here is reading/writing from <code>read_mbox</code></p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">bool</span> pcie_doe_read_config(DOECap *doe_cap, <span style="color:#fff;font-weight:bold">uint32_t</span> addr, <span style="color:#fff;font-weight:bold">int</span> size,
                          <span style="color:#fff;font-weight:bold">uint32_t</span> *buf)
{
    <span style="color:#fff;font-weight:bold">uint16_t</span> doe_offset = doe_cap-&gt;offset;


    addr -= doe_offset;
    *buf = <span style="color:#ff0;font-weight:bold">0</span>;

    <span style="color:#fff;font-weight:bold">if</span> (range_covers_byte(PCI_EXP_DOE_CAP, DWORD_BYTE, addr)) {
        *buf = FIELD_DP32(*buf, PCI_DOE_CAP_REG, INTR_SUPP,
                          doe_cap-&gt;cap.intr);
        *buf = FIELD_DP32(*buf, PCI_DOE_CAP_REG, DOE_INTR_MSG_NUM,
                          doe_cap-&gt;cap.vec);
    } <span style="color:#fff;font-weight:bold">else</span> <span style="color:#fff;font-weight:bold">if</span> (range_covers_byte(PCI_EXP_DOE_CTRL, DWORD_BYTE, addr)) {
        <span style="color:#007f7f">/* Must return ABORT=0 and GO=0 */</span>
        *buf = FIELD_DP32(*buf, PCI_DOE_CAP_CONTROL, DOE_INTR_EN,
                          doe_cap-&gt;ctrl.intr);
    } <span style="color:#fff;font-weight:bold">else</span> <span style="color:#fff;font-weight:bold">if</span> (range_covers_byte(PCI_EXP_DOE_STATUS, DWORD_BYTE, addr)) {
        *buf = FIELD_DP32(*buf, PCI_DOE_CAP_STATUS, DOE_BUSY,
                          doe_cap-&gt;status.busy);
        *buf = FIELD_DP32(*buf, PCI_DOE_CAP_STATUS, DOE_INTR_STATUS,
                          doe_cap-&gt;status.intr);
        *buf = FIELD_DP32(*buf, PCI_DOE_CAP_STATUS, DOE_ERROR,
                          doe_cap-&gt;status.error);
        *buf = FIELD_DP32(*buf, PCI_DOE_CAP_STATUS, DATA_OBJ_RDY,
                          doe_cap-&gt;status.ready);
    <span style="color:#007f7f">/* Mailbox should be DW accessed */</span>
    } <span style="color:#fff;font-weight:bold">else</span> <span style="color:#fff;font-weight:bold">if</span> (addr == PCI_EXP_DOE_RD_DATA_MBOX &amp;&amp; size == DWORD_BYTE) {
        <span style="color:#fff;font-weight:bold">if</span> (doe_cap-&gt;status.ready &amp;&amp; !doe_cap-&gt;status.error) {
            *buf = doe_cap-&gt;read_mbox[doe_cap-&gt;read_mbox_idx];
        }
    }

  ...
}
</code></pre></div><p>It&rsquo;s probably good idea to start from the top. <code>pcie_doe_init</code> adds capability and creates mailboxes. It&rsquo;s called from <code>cxl_usp_realize</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">void</span> pcie_doe_init(PCIDevice *dev, DOECap *doe_cap, <span style="color:#fff;font-weight:bold">uint16_t</span> offset,
                   DOEProtocol *protocols, <span style="color:#fff;font-weight:bold">bool</span> intr, <span style="color:#fff;font-weight:bold">uint16_t</span> vec)
{
    pcie_add_capability(dev, PCI_EXT_CAP_ID_DOE, <span style="color:#ff0;font-weight:bold">0x1</span>, offset,
                        PCI_DOE_SIZEOF);

    doe_cap-&gt;write_mbox = g_malloc0(PCI_DOE_DW_SIZE_MAX * DWORD_BYTE);
    doe_cap-&gt;read_mbox = g_malloc0(PCI_DOE_DW_SIZE_MAX * DWORD_BYTE);

    pcie_doe_reset_mbox(doe_cap);
}

</code></pre></div><p>Back to post-init write, when sender (linux kernel) writes to control register, it calls some handlers to handle control bits change. Also, in case of RD mailbox, qemu sets the ready bit in control reg.</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">void</span> pcie_doe_write_config(DOECap *doe_cap,
                           <span style="color:#fff;font-weight:bold">uint32_t</span> addr, <span style="color:#fff;font-weight:bold">uint32_t</span> val, <span style="color:#fff;font-weight:bold">int</span> size)
{

    <span style="color:#fff;font-weight:bold">switch</span> (addr) {
    <span style="color:#fff;font-weight:bold">case</span> PCI_EXP_DOE_CTRL:
        <span style="color:#fff;font-weight:bold">if</span> (FIELD_EX32(val, PCI_DOE_CAP_CONTROL, DOE_ABORT)) {
            pcie_doe_set_ready(doe_cap, <span style="color:#ff0;font-weight:bold">0</span>);
            pcie_doe_set_error(doe_cap, <span style="color:#ff0;font-weight:bold">0</span>);
            pcie_doe_reset_mbox(doe_cap);
            <span style="color:#fff;font-weight:bold">return</span>;
        }

        <span style="color:#fff;font-weight:bold">if</span> (FIELD_EX32(val, PCI_DOE_CAP_CONTROL, DOE_GO)) {
            pcie_doe_prepare_rsp(doe_cap);
        }
    ...
    ...
    ...
    <span style="color:#fff;font-weight:bold">case</span> PCI_EXP_DOE_RD_DATA_MBOX:
        <span style="color:#007f7f">/* Mailbox should be DW accessed */</span>
        <span style="color:#fff;font-weight:bold">if</span> (size != DWORD_BYTE) {
            <span style="color:#fff;font-weight:bold">return</span>;
        }
        doe_cap-&gt;read_mbox_idx++;
        <span style="color:#fff;font-weight:bold">if</span> (doe_cap-&gt;read_mbox_idx == doe_cap-&gt;read_mbox_len) {
            pcie_doe_reset_mbox(doe_cap);
            pcie_doe_set_ready(doe_cap, <span style="color:#ff0;font-weight:bold">0</span>);
        } <span style="color:#fff;font-weight:bold">else</span> <span style="color:#fff;font-weight:bold">if</span> (doe_cap-&gt;read_mbox_idx &gt; doe_cap-&gt;read_mbox_len) {
            <span style="color:#007f7f">/* Underflow */</span>
            pcie_doe_set_error(doe_cap, <span style="color:#ff0;font-weight:bold">1</span>);
        }
        <span style="color:#fff;font-weight:bold">break</span>;
    <span style="color:#fff;font-weight:bold">case</span> PCI_EXP_DOE_WR_DATA_MBOX:
        <span style="color:#007f7f">/* Mailbox should be DW accessed */</span>
        <span style="color:#fff;font-weight:bold">if</span> (size != DWORD_BYTE) {
            <span style="color:#fff;font-weight:bold">return</span>;
        }
        doe_cap-&gt;write_mbox[doe_cap-&gt;write_mbox_len] = val;
        doe_cap-&gt;write_mbox_len++;
        <span style="color:#fff;font-weight:bold">break</span>;
</code></pre></div><p><code>handle_request</code> is set depending on the protocol. In case of discovery request is sent, <code>pcie_doe_discovery</code> is called</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">void</span> pcie_doe_prepare_rsp(DOECap *doe_cap)
{

    <span style="color:#fff;font-weight:bold">if</span> (doe_cap-&gt;write_mbox[<span style="color:#ff0;font-weight:bold">0</span>] ==
        DATA_OBJ_BUILD_HEADER1(PCI_VENDOR_ID_PCI_SIG, PCI_SIG_DOE_DISCOVERY)) {
        handle_request = pcie_doe_discovery;
    } <span style="color:#fff;font-weight:bold">else</span> {
        <span style="color:#fff;font-weight:bold">for</span> (p = <span style="color:#ff0;font-weight:bold">0</span>; p &lt; doe_cap-&gt;protocol_num - <span style="color:#ff0;font-weight:bold">1</span>; p++) {
            <span style="color:#fff;font-weight:bold">if</span> (doe_cap-&gt;write_mbox[<span style="color:#ff0;font-weight:bold">0</span>] ==
                pcie_doe_build_protocol(&amp;doe_cap-&gt;protocols[p])) {
                handle_request = doe_cap-&gt;protocols[p].handle_request;
                <span style="color:#fff;font-weight:bold">break</span>;
            }
        }
    }

   ...
   ...
    <span style="color:#fff;font-weight:bold">if</span> (handle_request &amp;&amp; (doe_cap-&gt;write_mbox_len ==
        pcie_doe_get_obj_len(pcie_doe_get_write_mbox_ptr(doe_cap)))) {
        success = handle_request(doe_cap);
    }

    <span style="color:#fff;font-weight:bold">if</span> (success) {
        pcie_doe_set_ready(doe_cap, <span style="color:#ff0;font-weight:bold">1</span>);
    } <span style="color:#fff;font-weight:bold">else</span> {
        pcie_doe_reset_mbox(doe_cap);
    }
}

</code></pre></div><p>In <code>pcie_doe_discovery</code>, response is created(including setting next index) and call <code>pcie_doe_set_rsp</code></p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">bool</span> pcie_doe_discovery(DOECap *doe_cap)
{
    ...
    ...
    rsp.header = (DOEHeader) {
        .vendor_id = PCI_VENDOR_ID_PCI_SIG,
        .data_obj_type = PCI_SIG_DOE_DISCOVERY,
        .length = DIV_ROUND_UP(<span style="color:#fff;font-weight:bold">sizeof</span>(DoeDiscoveryRsp), DWORD_BYTE),
    };

    <span style="color:#fff;font-weight:bold">if</span> (index == <span style="color:#ff0;font-weight:bold">0</span>) {
        rsp.vendor_id = PCI_VENDOR_ID_PCI_SIG;
        rsp.data_obj_type = PCI_SIG_DOE_DISCOVERY;
    } <span style="color:#fff;font-weight:bold">else</span> {
        <span style="color:#fff;font-weight:bold">if</span> (index &lt; doe_cap-&gt;protocol_num) {
            prot = &amp;doe_cap-&gt;protocols[index - <span style="color:#ff0;font-weight:bold">1</span>];
            rsp.vendor_id = prot-&gt;vendor_id;
            rsp.data_obj_type = prot-&gt;data_obj_type;
        } <span style="color:#fff;font-weight:bold">else</span> {
            rsp.vendor_id = <span style="color:#ff0;font-weight:bold">0xFFFF</span>;
            rsp.data_obj_type = <span style="color:#ff0;font-weight:bold">0xFF</span>;
        }
    }

    <span style="color:#fff;font-weight:bold">if</span> (index + <span style="color:#ff0;font-weight:bold">1</span> == doe_cap-&gt;protocol_num) {
        rsp.next_index = <span style="color:#ff0;font-weight:bold">0</span>;
    } <span style="color:#fff;font-weight:bold">else</span> {
        rsp.next_index = index + <span style="color:#ff0;font-weight:bold">1</span>;
    }

    pcie_doe_set_rsp(doe_cap, &amp;rsp);

    <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">true</span>;
}
</code></pre></div><p><code>pcie_doe_set_rsp</code> just puts the response in <code>read_mbox</code></p>
<pre tabindex="0"><code>void pcie_doe_set_rsp(DOECap *doe_cap, void *rsp)
{
    uint32_t len = pcie_doe_get_obj_len(rsp);

    memcpy(doe_cap-&gt;read_mbox + doe_cap-&gt;read_mbox_len, rsp, len * DWORD_BYTE);
    doe_cap-&gt;read_mbox_len += len;
}
</code></pre>
      </div>
    </article>

    <hr />

    <div class="post-info">
      
    <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line></svg>

        <span class="tag"><a href="tags/qemu/">qemu</a></span>
        <span class="tag"><a href="tags/pcie/">pcie</a></span>
        
    </p>

      

      <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text">
          <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
          <polyline points="14 2 14 8 20 8"></polyline>
          <line x1="16" y1="13" x2="8" y2="13"></line>
          <line x1="16" y1="17" x2="8" y2="17"></line>
          <polyline points="10 9 9 9 8 9"></polyline>
        </svg>
        628 Words
      </p>

      <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar">
          <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
          <line x1="16" y1="2" x2="16" y2="6"></line>
          <line x1="8" y1="2" x2="8" y2="6"></line>
          <line x1="3" y1="10" x2="21" y2="10"></line>
        </svg>
        
          2023-04-01 01:00 &#43;0100
        

         
          
        
      </p>
    </div>

    
      <div class="pagination">
        <div class="pagination__title">
          <span class="pagination__title-h">Read other posts</span>
          <hr />
        </div>

        <div class="pagination__buttons">
          

          
            <span class="button next">
              <a href="/posts/2023/04/qemu-pcie-sriov-and-virtual-function/">
                <span class="button__text">Qemu - PCIe SRIOV and virtual function</span>
                <span class="button__icon">→</span>
              </a>
            </span>
          
        </div>
      </div>
    


    

    

  </main>

            </div>

            
                <footer class="footer">
    <div class="footer__inner">
        <div class="footer__content">
            <span>&copy; 2023</span>
            
            <span><a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0</a></span><span><a href="posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a></span>
        </div>
    </div>
    <div class="footer__inner">
        <div class="footer__content">
            <span>Powered by <a href="http://gohugo.io">Hugo</a></span>
            <span>Made with &#10084; by <a href="https://github.com/rhazdon">Djordje Atlialp</a></span>
          </div>
    </div>
</footer>

            
        </div>

        



<script type="text/javascript" src="/bundle.min.2ce64ea6ea44a72b13dd812fc2eb5cca3efe878cce258a47c137c17edf46e0602a05e422b618a5b80b5939c731b7a293351c2f2222a21f6ee27e54a8448dd20e.js" integrity="sha512-LOZOpupEpysT3YEvwutcyj7&#43;h4zOJYpHwTfBft9G4GAqBeQithiluAtZOccxt6KTNRwvIiKiH27iflSoRI3SDg=="></script>



    </body>
</html>
